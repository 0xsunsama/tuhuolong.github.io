---
layout: post
title: "Dalvik漫谈"
date: 2011-05-17 15:11:00 
comments: true
categories: [jni]
tags: [jni]
description: "Dalvik漫谈"
keywords: jni
---


 
  
   
    
     
      由於
     
     
      Dalvik
     
     
      所涉及的範圍不少
     
     
      ,
     
     
      從
     
     
      JNI
     
     
      介面
     
     
      ,Trace-JIT
     
     
      的實作
     
     
      ,
     
     
      到最佳化的技巧
     
     
      ,
     
     
      筆者在本文只會針對自己挑選的區塊以
     
     
      Android 2.2 Source Code
     
     
      加以說明
     
     
      .
     
     
      同樣的
     
     
      ,
     
     
      所有涉及的內容
     
     
      ,
     
     
      都會隨著
     
     
      Android
     
     
      程式碼的改版而有所差異
     
     
      ,
     
     
      還請以最新取得的
     
     
      Package
     
     
      為主
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      在此以引用侯捷曾說過的
     
     
     
     
      "
     
     
      源碼之前了無秘密
     
     
      ",
     
     
      對有志於深入探究
     
     
      Dalvik
     
     
      運作原理的人而言
     
     
      ,Android
     
     
      所釋出的
     
     
      Source Code,
     
     
      就是最好的
     
     
      Handbook.
     
    
    
     
     
    
    
     
      
      
     
     
      參考
     
     
      Google
     
     
      的文件
     
     
      ,
     
     
      我們知道
     
     
      Dalvik
     
     
      是
     
     
      Google
     
     
      在
     
     
      Android
     
     
      手機上所提供的
     
     
      ByteCode
     
     
      虛擬器
     
     
      ,
     
     
      所預定的目標是要能運作在效能需求不高
     
     
      ,
     
     
      較少的記憶體
     
     
      ,
     
     
      與使用慢速的內部
     
     
      Flash
     
     
      儲存
     
     
      ,
     
     
      作業系統要能支援虛擬記憶體
     
     
      ,
     
     
      執行行程與執行緒
     
     
      (Process/Thread),
     
     
      與具備使用者帳號安全管理機制
     
     
      (UID-based security mechanisms),
     
     
      並能透過
     
     
      GNU C
     
     
      編譯器編譯後運作在包括
     
     
      Linux,BSD
     
     
      與
     
     
      Mac OS X
     
     
      等
     
     
      Unix
     
     
      環境下
     
     
      ,
     
     
      並支援
     
     
      Little-endian
     
     
      與
     
     
      Big-endian
     
     
      處理器執行環境
     
     
      .
     
     
      核心的函式庫主要是承襲
     
     
      Open Source
     
     
      的
     
     
      Java SE
     
     
      實作
     
     
      Apache Harmony
     
     
      而來
     
     
      (
     
     
      網址
     
     
      :
      
       http://harmony.apache.org/
      
      ),
     
     
      並基於
     
     
      Open Source
     
     
      中相關
     
     
      OpenSSL, zlib
     
     
      與
     
     
      ICU
     
     
      （
     
     
      International Components for Unicode)
     
     
      的計畫成果
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      一般虛擬器的設計
     
     
      ,
     
     
      會在應用程式啟動時
     
     
      ,
     
     
      動態的從儲存裝置讀取並解壓縮個別的
     
     
      Classes
     
     
      到記憶體中
     
     
      ,
     
     
      在沒有經過適度優化的架構下
     
     
      ,
     
     
      每個獨立的虛擬器行程
     
     
      ,
     
     
      都會包含自己一份的相關
     
     
      Classes
     
     
      記憶體空間
     
     
      ,
     
     
      對於程式載入的固定成本與執行效率上
     
     
      ,
     
     
      不容易有較好的表現
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      因此
     
     
      ,
     
     
      參考
     
     
      Google
     
     
      文件
     
     
      ,Dalvik
     
     
      設計之初
     
     
      ,
     
     
      基於上述的特徵與限制
     
     
      ,
     
     
      主要著重在以下的目標
     
     
      ,
     
    
    
     
      
      
     
     
      1,Class Data尤其是共用的ByteCode,要能跨行程共用,節省系統整體記憶體需求(參考Process Memory Map (in /proc/xxxx/maps),目前包括相關的 jar與所包含的Bytecode Dex檔案,都能跨行程在不同的Dalvik行程中共用).
     
    
    
     
      
      
      2,減少Dalvik應用程式載入啟動的成本,加速應用程式的反應時間
     
    
    
     
      
      
      3,Class Data儲存在個別的檔案中,導致額外的儲存成本,針對儲存空間的需求需要多加注意.
     
    
    
     
      
      
      4,要從Class Data中讀取出資料數值( 例如:整數或是字串)會增加不必要的成本,評估如何採用C 的形式存取,會是有必要的.
     
    
    
     
      
      
      5,ByteCode的驗證雖耗時但卻是必要的,應該試著在程式執行前完成驗證.
     
    
    
     
      
      
      6,透過快速指令集與機制的優化進行ByteCode的最佳化對於執行效率與電池壽命是相當重要的.
     
    
    
     
      
      
      7,為了安全需求,執行中的行程不能修改共享的程式碼.
     
    
    
     
     
    
    
     
      
      
     
     
      基於上述目標
     
     
      ,Dalvik
     
     
      在設計時
     
     
      ,
     
     
      作了以下的決定
     
    
    
     
     
    
    
     
      
      
      1,
     
     
      可以把多個
     
     
      Classes
     
     
      檔案整合到一個
     
     
     
     
      DEX
     
     
      檔案中
     
    
    
     
      
      
      2,DEX
     
     
      檔案會以唯讀方案載入到記憶體中
     
     
      ,
     
     
      並跨行程共享
     
    
    
     
      
      
      3,
     
     
      因應支援的系統架構
     
     
      ,
     
     
      調整
     
     
      Byte Ordering
     
     
      與
     
     
      Word Alignment.
     
    
    
     
      
      
      4,ByteCode
     
     
      驗證對所有的
     
     
      Classes
     
     
      都是必要的
     
     
      ,
     
     
      且會儘可能進行事先的驗證加速系統效率
     
     
      .
     
    
    
     
      
      
      5,
     
     
      對於需修改
     
     
      ByteCode
     
     
      的最佳化動作
     
     
      ,
     
     
      會在執行前完成
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      在
     
     
      dalvik
     
     
      上通常會以
     
     
      .apk
     
     
      的方式來提供應用程式的封裝
     
     
      ,
     
     
      或以
     
     
      .jar
     
     
      的方式來提供
     
     
      Framework
     
     
      函式庫
     
     
      ,
     
     
      這些包裝格式主要是以
     
     
      zip
     
     
      的形式壓縮內容並加上相關的參考資訊
     
     
      ,
     
     
      儲存在檔案系統中
     
     
      ,
     
     
      並達到節省儲存空間的目的
     
     
      .
     
     
      也因此
     
     
      ,
     
     
      在執行前必須要進行解壓縮的動作
     
     
      ,
     
     
      把
     
     
      DEX
     
     
      檔案載入到記憶體中執行
     
     
      . DEX
     
     
      檔案可包括多個
     
     
      Classes
     
     
      檔案
     
     
      ,
     
     
      並以
     
     
     
     
      classes.dex
     
     
      檔名結尾
     
     
      .
     
    
    
     
     
    
    
     
      
       DEX
      
     
     
      
       的驗證與最佳化
      
     
     
     
    
    
     
     
    
    
     
      
      
     
     
      系統可以在
     
     
      VM
     
     
      進行
     
     
      JIT(Just in time),
     
     
      第一次安裝或在系統編譯時
     
     
      ,
     
     
      進行最佳化
     
     
      DEX
     
     
      檔案的動作
     
     
      (ODEX - Optimized DEX),
     
     
      如果是在裝置上進行的最佳化動作
     
     
      ,
     
     
      會把最佳化後的檔案存放到
     
     
     
     
      dalvik-cache
     
     
      目錄下
     
     
      (
     
     
      例如
     
     
      :/data/dalvik-cache/system@framework@ext.
      
       jar@classes.dex
      
      ),
     
     
      若是在編譯階段的最佳化動作
     
     
      ,
     
     
      則是把最佳化後的
     
     
      DEX
     
     
      檔案存放在
     
     
      jar/apk
     
     
      格式的
     
     
      ZIP
     
     
      壓縮檔案中
     
     
      ,
     
     
      可成為產品出貨時預設
     
     
      System Image
     
     
      的一部分
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      執行時期的
     
     
      dalvik-cache
     
     
      目錄權限為
     
     
      0771
     
     
      並屬於
     
     
      system
     
     
      使用者與
     
     
      system
     
     
      群組
     
     
      (
     
     
      例如
     
     
      :drwxrwx--x system
      
      
      system),
     
     
      最佳化後的
     
     
      DEX
     
     
      檔案權限為
     
     
      0644
     
     
      並屬於
     
     
      system
     
     
      使用者與使用者群組
     
     
      (
     
     
      例如
     
     
      :-rw-r--r-- system
      
      
      app_29),
     
     
      而有被
     
     
      DRM-locked
     
     
      保護的應用程式最佳化後的
     
     
      DEX
     
     
      檔案權限會設定為
     
     
      0640
     
     
      以避免其他應用程式取得檔案資料
     
     
      .
     
    
    
     
      
      
     
    
    
     
      
      
      Android SDK
     
     
      中的
     
     
      System.img
     
     
      所包含的
     
     
      init.rc,
     
     
      在啟動過程中會進行如下的配置
     
    
    
     
     
    
    
     
      
      
      # create dalvik-cache and double-check the perms
     
    
    
     
      
      
      mkdir /data/dalvik-cache 0771 system system
     
    
    
     
      
      
      chown system system /data/dalvik-cache
     
    
    
     
      
      
      chmod 0771 /data/dalvik-cache
     
    
    
     
     
    
    
     
      
      
     
     
      最佳化
     
     
      DEX
     
     
      的動作會產生一個可供快速載入執行的
     
     
      classes.dex
     
     
      檔案
     
     
      ,
     
     
      並會進行包括
     
     
      byte-swapping,structure realigning
     
     
      與
     
     
      basic structure checks,
     
     
      更新
     
     
      ODEX
     
     
      （
     
     
      Optimized DEX)header ,
     
     
      為了確保產生
     
     
      ODEX
     
     
      流程的正確性
     
     
      ,Android
     
     
      提供了一個
     
     
      dexopt
     
     
      工具
     
     
      (
     
     
      原始碼在
     
     
      dalvik/dexopt),
     
     
      用來作為一個
     
     
      Dalvik
     
     
      虛擬器的輔助工具
     
     
      ,
     
     
      可以在系統啟動時
     
     
      ,
     
     
      透過
     
     
      Dalvik
     
     
      虛擬器對載入的
     
     
      DEX
     
     
      檔案執行最佳化的動作
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      工具
     
     
      dexopt
     
     
      在
     
     
      Android
     
     
      系統中有兩種使用的時機
     
     
      ,
     
    
    
     
      
      
      1,
     
     
      由
     
     
      Dalvik
     
     
      虛擬器來執行
     
     
      ,
     
     
      在有多個
     
     
      Dalvik
     
     
      虛擬器執行的環境中
     
     
      ,
     
     
      會透過
     
     
      dexopt locks
     
     
      確保同一個
     
     
      DEX
     
     
      檔案只會執行到一次
     
     
      .
     
    
    
     
      
      
      2,
     
     
      在安裝應用程式時
     
     
      ,
     
     
     
     
      會把檔案從
     
     
      ZIP
     
     
      壓縮中解開
     
     
      ,
     
     
      再透過
     
     
      dexopt
     
     
      進行驗證與最佳化
     
    
    
     
     
    
    
     
      
      
      
     
     
      針對
     
     
      DEX
     
     
      檔案所進行的驗證與最佳化程序內容
     
     
      ,
     
     
      如下簡介
     
    
    
     
      
      
      1,
     
     
      驗證
     
     
      :
     
    
    
     
      
      
     
     
      會包括
     
     
      DEX
     
     
      檔案中所包括的每個
     
     
      Classes
     
     
      集合以及每個指令集
     
     
      ,
     
     
      確保不會在
     
     
      Run-Time
     
     
      階段遇到不適當的指令集
     
     
      ,
     
     
      一般而言
     
     
      ,Dalvik
     
     
      只有針對被驗證過的
     
     
      Classes
     
     
      進行依據平台的最佳化流程
     
     
      (
     
     
      這條件是可修改的
     
     
      ,
     
     
      甚至也可忽略驗證階段只進行最佳化
     
     
      ),
     
     
      如果呼叫了一個被驗證失敗的
     
     
      Class
     
     
      所提供的呼叫
     
     
      ,
     
     
      就會導致
     
     
      Dalvik
     
     
      虛擬器發生
     
     
      Exception
     
     
      例外
     
     
      , DEX
     
     
      中的
     
     
      Class
     
     
      一旦被驗證過
     
     
      ,
     
     
      就會被記錄在
     
     
      ODEX
     
     
      格式的欄位中
     
     
      (
     
     
      包含
     
     
      32-bit check-sum),
     
     
      如此可以避免下次載入時
     
     
      ,
     
     
      還要重複進行驗證的工作
     
     
      .
     
    
    
     
     
    
    
     
      
      
      2,
     
     
      最佳化
     
     
      :
     
    
    
     
      
      
     
     
      會包括把數值資料的定義
     
     
      ,
     
     
      透過指標對應到內部的資料結構
     
     
      ,
     
     
      把一定成功或是特定行為的指令流程置換為比較簡單的形式
     
     
      ,
     
     
      除了必須要在
     
     
      Run-Time
     
     
      才能取得的資訊外
     
     
      ,
     
     
      會把可以先決定的資訊先靜態處理完畢
     
     
      .
     
    
    
     
      
      
      A,
     
     
      以
     
     
      vtable Index
     
     
      置換虛擬函式
     
     
      (virtual method calls)Index
     
    
    
     
      
      
      B,
     
     
      變數的存取
     
     
      ,
     
     
      會以實際資料的
     
     
      Byte Offset
     
     
      置換
     
     
      ,
     
     
      並且會把資料型別為
     
     
      boolean / byte / char / short
     
     
      等變數
     
     
      ,
     
     
      轉為
     
     
      32bits
     
     
      的形式儲存
     
    
    
     
      
      
      C,
     
     
      置換大量調用的函式
     
     
      ,
     
     
      例如
     
     
     
     
      String.length()
     
     
      透過
     
     
     
     
      Inline
     
     
      的置換
     
     
      ,
     
     
      直接由
     
     
      Intepreter
     
     
      呼叫到原生函式的實作
     
     
      ,
     
     
      減輕函式呼叫的成本
     
     
      ,
     
    
    
     
      
      
      D,
     
     
      移除空函式的實作
     
     
      ,
     
     
      例如
     
     
      Class
     
     
      物件的
     
     
      init
     
     
      空函式
     
     
      ,
     
     
      在每次物件被配置時
     
     
      ,
     
     
      都還是會被呼叫
     
     
      ,
     
     
      就會以
     
     
      nop
     
     
      指令集
     
     
      (0x00)
     
     
      取代
     
     
      .
      
      
     
    
    
     
      
      
      E,
     
     
      將可以預先計算的資料
     
     
      ,
     
     
      進行預處理
     
     
      .
     
    
    
     
      
      
      F,
     
     
      會以
     
     
      Dalvik
     
     
      規格中沒有制定的
     
     
      OpCode
     
     
      指令集來進行最佳化
     
     
      ,
     
     
      這部份會交由
     
     
      dexopt
     
     
      根據
     
     
      Dalvik
     
     
      虛擬器的版本去決定哪些部分要置換
     
     
      .
     
    
    
     
      
      
      G.
     
     
      最佳化的流程
     
     
      ,
     
     
      也可以看做是跟
     
     
      ELF
     
     
      執行檔與動態函式庫間解決
     
     
      Symbol Resolve
     
     
      的問題
     
     
      ,
     
    
    
     
      
      
     
    
    
     
     
    
    
     
      
      
     
     
      上述的最佳化動作
     
     
      ,
     
     
      也會使用到來自其他
     
     
      DEX
     
     
      檔案中的
     
     
      Class,
     
     
      如果所參考到的
     
     
      Class
     
     
      資料的內容或是函式有所變動
     
     
      ,
     
     
      就會有相依性的問題要被處理
     
     
      ,
     
     
      並且要針對變動的部份重新進行最佳化的動作
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
    
    
     
      
       DEX
      
     
     
      
       相依性
      
     
     
      
       .
      
     
    
    
     
      
      
     
    
    
     
      
      
     
     
      由於
     
     
      ,
     
     
      最佳化時
     
     
      ,
     
     
      會把系統相依的問題進行解決
     
     
      ,
     
     
      以加速應用程式載入的效率
     
     
      ,
     
     
      也因此
     
     
      ,
     
     
      這些在最佳化時所仰賴的相關
     
     
      DEX
     
     
      檔案如果有變動的話
     
     
      ,
     
     
      就有機會導致原本最佳化的結果可能造成因為版本差異的所導致的系統問題
     
     
      ,
     
     
      也因此
     
     
      ,
     
     
      最佳化過的
     
     
      ODEX
     
     
      （
     
     
      Optimized DEX)
     
     
      檔案中會包括所相依的
     
     
      DEX
     
     
      檔案清單以及其
     
     
      CRC-32,
     
     
      時間資訊
     
     
      ,
     
     
      對應到
     
     
      dalvik-cache
     
     
      的完整路徑
     
     
      ,SHA-1
     
     
      簽名
     
     
      ,Dalvik
     
     
      虛擬器版本編號
     
     
      .
     
     
      基於此
     
     
      ,
     
     
      如果啟動目錄下的
     
     
      DEX
     
     
      檔案變動
     
     
      ,
     
     
      也就象徵著會導致系統上一次相依到該
     
     
      DEX
     
     
      檔案的驗證與最佳化流程
     
     
      ,
     
     
      需要被重新執行
     
     
      .
     
     
      如果使用者自定的
     
     
      Class
     
     
      命名與啟動路目錄下的
     
     
      Class
     
     
      名稱重複
     
     
      ,
     
     
      系統會對該
     
     
      Class
     
     
      標註並且該參考將不會被驗證與最佳化流程解析
     
     
      .
     
     
      如果
     
     
      DEX
     
     
      檔案在安裝時就是以
     
     
      ODEX
     
     
      的形式安裝
     
     
      ,
     
     
      且他所相依的
     
     
      DEX
     
     
      檔案被更新過
     
     
      ,
     
     
      這將會導致
     
     
      dexopt
     
     
      沒有辦法對該
     
     
      DEX
     
     
      檔案依據目前系統的狀況進行最佳化產生
     
     
      ODEX,
     
     
      此時
     
     
      Dalvik
     
     
      虛擬器將會拒絕該
     
     
      DEX
     
     
      檔案安裝
     
     
      .
     
    
    
     
     
    
    
     
     
    
    
     
      
       Dalvik
      
     
     
      
       雜談
      
     
     
     
    
    
     
     
    
    
     
      
      
      Dalvik
     
     
      虛擬器支援大約
     
     
      230
     
     
      多個指令集
     
     
      OpCode,
     
     
      其中也包含部分由
     
     
      Dexopt
     
     
      插入到
     
     
      ByteCode
     
     
      執行檔中但目前尚未在
     
     
      Android
     
     
      文件
     
     
      ”Bytecode for the Dalvik VM”
     
     
      說明的
     
     
      OpCode
     
     
      指令
     
     
      .
     
    
    
     
      
      
     
     
      主要的
     
     
      Dalvik
     
     
      虛擬器實作
     
     
      ,
     
     
      都是基於
     
     
      C Code,
     
     
      並具有平台移植性
     
     
      ,
     
     
      除了
     
     
      JIT(Byte-Code Compiler to ARM/x86 Code)
     
     
      與
     
     
      JNI(Java Native Interface) Call Bridge
     
     
      有牽涉到跟平台有關的組語優化實作
     
     
      ,
     
     
      這會牽涉到包括如何把
     
     
      Byte-Code
     
     
      針對
     
     
      ARMv5,ARMv7,VFP
     
     
      與
     
     
     
     
      NEON
     
     
      指令集進行動態的產生與優化
     
     
      ,
     
     
      以及由
     
     
      Java
     
     
      端呼叫到
     
     
      Native
     
     
      函式時
     
     
      ,
     
     
      要如何根據平台的差異去針對例如
     
     
      C
     
     
      語言的函式參數傳遞進行優化
     
     
      (
     
     
      例如
     
     
      :x86
     
     
      的函式參數傳遞
     
     
      ,
     
     
      是由右往左推到
     
     
      Stack
     
     
      中
     
     
      ,
     
     
      而
     
     
      ARM
     
     
      的函式參數傳遞
     
     
      ,
     
     
      是由左到右依序放到
     
     
      R0,R1,R2,R3
     
     
      通用暫存器
     
     
      ),
     
     
      與函式呼叫與傳回值
     
     
      (
     
     
      例如
     
     
      :x86
     
     
      會根據傳回值的
     
     
      Type
     
     
      決定要用
     
     
      EAX
     
     
      或加上
     
     
      EDX
     
     
      暫存器
     
     
      ,
     
     
      或是
     
     
      ARM
     
     
      會決定要用到
     
     
      R0
     
     
      或加上
     
     
      R1
     
     
      暫存器
     
     
      ).
     
     
      若你所使用的平台
     
     
      ,
     
     
      並不在
     
     
      Dalvik JNI Call Bridge
     
     
      支援中
     
     
      ,Google
     
     
      文件中也建議可以參考
     
     
     
     
      open-source FFI library (A Portable Foreign Function Interface Library,
     
     
      網址
     
     
      :
      
       http://sourceware.org/libffi/
      
      ),
     
     
      裡面有關於不同平台的可移植函式呼叫實作
     
     
      .
     
     
      對應到
     
     
      Dalvik
     
     
      中這部分的實作位於
     
     
      Source Code
     
     
      的
     
     
      dalvik/vm/arch/
     
     
      目錄下
     
     
      ,
     
     
      裡面有關於
     
     
      Java
     
     
      透過
     
     
      JNI
     
     
      機制呼叫到
     
     
      Native Code
     
     
      的實作函式
     
     
      void dvmPlatformInvoke(void* pEnv, ClassObject* clazz, int argInfo, int argc, const u4* argv, const char* signature, void* func, JValue* pReturn) (
     
     
      例如
     
     
      :
     
     
      在
     
     
      x86
     
     
      目錄下實作是在
     
     
      Call386ABI.S
     
     
      與
     
     
      Hints386ABI.c,arm
     
     
      目錄下實作是
     
     
      CallEABI.S,CallOldABI.S
     
     
      與
     
     
      HintsEABI.c,
     
     
      或
     
     
      generic
     
     
      目錄下的實作
     
     
      Call.c
     
     
      與
     
     
     
     
      Hints.c),
     
     
      其中
     
     
      ,
     
     
      也有包括關於
     
     
      SH
     
     
      處理器
     
     
      Call Bridge
     
     
      的實作
     
     
      ,
     
     
      這是由
     
     
      Hitachi
     
     
      與
     
     
     
     
      Renesas
     
     
      公司實作後
     
     
      ,
     
     
      貢獻到
     
     
      Android
     
     
      計畫中
     
     
      .(
     
     
      ㄟ
     
     
      ....
     
     
      那
     
     
      MIPS
     
     
      也應該要這樣子做吧
     
     
      ...@_@)
     
    
    
     
     
    
    
     
      
      
     
     
      函式
     
     
     
     
      dvmPlatformInvoke
     
     
      主要目的是會用來把我們在
     
     
      Java
     
     
      端呼叫
     
     
      JNI
     
     
      函式時所帶入的參數
     
     
      ,
     
     
      用
     
     
      C
     
     
      函式參數傳遞的原則進行調整
     
     
      ,
     
     
      與處理
     
     
      C
     
     
      函式的回傳值對應回
     
     
      Java
     
     
      的世界中
     
     
      .
     
    
    
     
     
    
    
     
      
      
      Dalvik
     
     
      支援兩種
     
     
      Java
     
     
      虛擬器的直譯器
     
     
      ,
     
     
      一個是最早的版本
     
     
      ,
     
     
      在文件中稱為
     
     
      Portabl Interpreter,
     
     
      所在原始碼路徑為
     
     
      dalvik/vm/mterp/portable,
     
     
      這個
     
     
      all-in-one-function
     
     
      的
     
     
      C
     
     
      實作
     
     
      ,
     
     
      可以用來編譯到不同的平台上
     
     
      ,
     
     
      並支援
     
     
      Profiling
     
     
      與除錯機制
     
     
      ,
     
     
      根據
     
     
      Config
     
     
      的設定
     
     
      ,
     
     
      所在編譯環境會納入編譯的
     
     
      Java
     
     
      虛擬器的直譯器實作會把
     
     
      Source Code
     
     
      放到
     
     
      dalvik/vm/mterp/out
     
     
      目錄下
     
     
      .
     
    
    
     
     
    
    
     
      
      
      Dalvik
     
     
      也支援根據不同平台透過組語優化後的直譯器版本
     
     
      ,
     
     
      在文件中稱為
     
     
      Fast Interpreter,
     
     
      可以藉由優化後的平台組語實作
     
     
      ,
     
     
      得到更好的
     
     
      Java
     
     
      虛擬器執行效能
     
     
      ,
     
     
      在
     
     
      dalvik/vm/mterp/out
     
     
      目錄下可以看到依據平台不同而命名的
     
     
      InterpC-<arch>;.c, InterpAsm-<arch>;.S
     
     
      原始碼
     
     
      ,
     
     
      並可針對不同平台的差異採用不同的優化指令集
     
     
      ,
     
     
      例如
     
     
      :
     
     
      在
     
     
      ARM11(ARMv6)
     
     
      架構下可以使用
     
     
     
     
      PLD
     
     
      指令
     
     
      ,
     
     
      與在
     
     
      ARM7(ARMv4T)
     
     
      架構下要避免使用
     
     
      CLZ
     
     
      指令
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      組語版本的優化程式碼
     
     
      ,
     
     
      會以
     
     
      64bytes Memory Alignment
     
     
      配置來實作每一個對應的
     
     
      Java
     
     
      指令
     
     
      (
     
     
      也就是說每個
     
     
      Java
     
     
      指令最多可以用
     
     
      16
     
     
      個
     
     
      ARM 32bits
     
     
      指令集實作
     
     
      ),
     
     
      如果在
     
     
      Dalvik
     
     
      虛擬器啟動時
     
     
      ,
     
     
      發現有對應實作的
     
     
      Java
     
     
      指令超過定義的大小
     
     
      ,
     
     
      就會由虛擬器產生錯誤
     
     
      (Abort),
     
     
      參考
     
     
      InterpAsm-armv5te.S,
     
     
      如下指令集實作
     
    
    
     
     
    
    
     
      
      
      .balign 64
     
    
    
     
      .L_OP_MOVE_16: /* 0x03 */
     
    
    
     
      /* File: armv5te/OP_MOVE_16.S */
     
    
    
     
      
      
      /* for: move/16, move-object/16 */
     
    
    
     
      
      
      /* op vAAAA, vBBBB */
     
    
    
     
      
      
      FETCH(r1, 2)
      
      
      @ r1<- BBBB
     
    
    
     
      
      
      FETCH(r0, 1)
      
      
      @ r0<- AAAA
     
    
    
     
      
      
      FETCH_ADVANCE_INST(3)
      
      
      @ advance rPC, load rINST
     
    
    
     
      
      
      GET_VREG(r2, r1)
      
      
      @ r2<- fp[BBBB]
     
    
    
     
      
      
      GET_INST_OPCODE(ip)
      
      
      @ extract opcode from rINST
     
    
    
     
      
      
      SET_VREG(r2, r0)
      
      
      @ fp[AAAA]<- r2
     
    
    
     
      
      
      GOTO_OPCODE(ip)
      
      
      @ jump to next instruction
     
    
    
     
      或
     
    
    
     
      
      
      .balign 64
     
    
    
     
      .L_OP_MOVE_WIDE: /* 0x04 */
     
    
    
     
      /* File: armv5te/OP_MOVE_WIDE.S */
     
    
    
     
      
      
      /* move-wide vA, vB */
     
    
    
     
      
      
      /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */
     
    
    
     
      
      
      mov
      
      
      r2, rINST, lsr #8
      
      
      @ r2<- A(+)
     
    
    
     
      
      
      mov
      
      
      r3, rINST, lsr #12
      
      
      @ r3<- B
     
    
    
     
      
      
      and
      
      
      r2, r2, #1
     
    
    
     
      
      
      add
      
      
      r3, rFP, r3, lsl #2
      
      
      @ r3<- &fp[B]
     
    
    
     
      
      
      add
      
      
      r2, rFP, r2, lsl #2
      
      
      @ r2<- &fp[A]
     
    
    
     
      
      
      ldmia
      
      
      r3, {r0-r1}
      
      
      @ r0/r1<- fp[B]
     
    
    
     
      
      
      FETCH_ADVANCE_INST(1)
      
      
      @ advance rPC, load rINST
     
    
    
     
      
      
      GET_INST_OPCODE(ip)
      
      
      @ extract opcode from rINST
     
    
    
     
      
      
      stmia
      
      
      r2, {r0-r1}
      
      
      @ fp[A]<- r0/r1
     
    
    
     
      
      
      GOTO_OPCODE(ip)
      
      
      @ jump to next instruction
     
    
    
     
     
    
    
     
      
      
     
     
      也可以參考網頁
     
     
      
       http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html
      
      ,
     
     
      有整理好的
     
     
      Dalvik Java OpCode,
     
     
      對比
     
     
      Sun Java
     
     
      的
     
     
      OpCode (
     
     
      可以參考網頁
     
     
      :
      
       http://java.sun.com/docs/books/jvms/second_edition/html/Mnemonics.doc.html
      
      
      
     
     
      或是比較完整的文件
     
     
      
       http://java.sun.com/docs/books/jvms/second_edition/Java5-Instructions2.pdf
      
      ),
     
     
      對比之後可以知道雖然都是透過
     
     
      JDK
     
     
      編譯的程式碼
     
     
      ,
     
     
      透過
     
     
      Google Android Dex
     
     
      轉換後
     
     
      ,
     
     
      就會變成
     
     
      Dalvik
     
     
      專屬的
     
     
      OpCode
     
     
      在
     
     
      Dalvik
     
     
      自己的
     
     
      Java
     
     
      虛擬器上執行
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      針對使用者所採用平台的組語優化程式碼
     
     
      ,
     
     
      可以透過
     
     
      dalvik/vm/mterp/config-<Arch>;
     
     
      相關檔案來決定
     
     
      ,
     
     
      其中包括要
     
     
      import
     
     
      哪一部分的實作
     
     
      ,
     
     
      也規避掉了
     
     
      ARM
     
     
      在不同架構上支援指令集的差異
     
     
      .
     
     
      以
     
     
      dalvik/vm/mterp/config-armv4t
     
     
      為例
     
     
      ,
     
     
      擷取其中關於
     
     
      opcode
     
     
      的部分來說明如下
     
    
    
     
     
    
    
     
      # opcode list; argument to op-start is default directory
     
    
    
     
      op-start armv5te
     
    
    
     
      
      
      op OP_AGET_WIDE armv4t
     
    
    
     
      
      
      op OP_APUT_WIDE armv4t
     
    
    
     
      
      
      op OP_IGET_WIDE armv4t
     
    
    
     
      
      
      op OP_IGET_WIDE_QUICK armv4t
     
    
    
     
      
      
      op OP_IPUT_WIDE armv4t
     
    
    
     
      
      
      op OP_IPUT_WIDE_QUICK armv4t
     
    
    
     
      
      
      op OP_SGET_WIDE armv4t
     
    
    
     
      
      
      op OP_SPUT_WIDE armv4t
     
    
    
     
      op-end
     
    
    
     
     
    
    
     
      
      
     
     
      上述宣告
     
     
      ,
     
     
      最後產生的
     
     
      dalvik/vm/mterp/out/InterpAsm-armv4t.S
     
     
      除上述
     
     
      AGET_WIDE,APUT_WIDE,IGET_WIDE,IGET_WIDE_QUICK,IPUT_WIDE,IPUT_WIDE_QUICK,SGET_WIDE
     
     
      與
     
     
      SPUT_WIDE
     
     
      指令集會用
     
     
      armv4t
     
     
      的實作外
     
     
      ,
     
     
      其他指令集會用
     
     
      armv5te
     
     
      的指令集架構實現
     
     
      .
     
     
      如果有修改上述指令集的實作
     
     
      ,
     
     
      會需要執行
     
     
      dalvik/vm/mterp/rebuild.sh,
     
     
      重新產生
     
     
      dalvik/vm/mterp/out/
     
     
      下對應到相關處理器架構的
     
     
      Java
     
     
      指令集實作
     
     
      .
     
     
      並重新編譯
     
     
      dalvik
     
     
      目錄
     
     
      ,
     
     
      以便產生對應這次修改的
     
     
     
     
      libdvm.so .
     
    
    
     
     
    
    
     
      
      
     
     
      Fast Interpreter
     
     
      會是預設的
     
     
      Dalvik
     
     
      虛擬器中的直譯器
     
     
      ,
     
     
      如果你所在的處理器沒有
     
     
      Dalvik
     
     
      的組語實作支援
     
     
      ,
     
     
      可以由使用者在啟動時選擇要用
     
     
      C Code
     
     
      版本的
     
     
      Portable Interpreter,
     
     
      只要在啟動時
     
     
      (
     
     
      例如在
     
     
      init.rc
     
     
      中
     
     
      )
     
     
      執行
     
     
      “
      
       echo dalvik.vm.execution-mode = int:portable >;>; /data/local.prop
      
      “,
     
     
      就可以選擇採用
     
     
      Portable Interpreter.
     
    
    
     
     
    
    
     
      
      
     
     
      一般
     
     
      Java
     
     
      虛擬器直譯器的實作
     
     
      ,
     
     
      最直覺的寫法就是用一個很大的
     
     
      Switch-Case,
     
     
      依序對應每個進來的指令集
     
     
      OpCode,
     
     
      做出對應
     
     
      OpCode
     
     
      的行為
     
     
      ,
     
     
      在每個指令集
     
     
      OpCode
     
     
      執行完畢後
     
     
      ,
     
     
      就回到迴圈的頭
     
     
      ,
     
     
      重新
     
     
      Fetch
     
     
      下一次的指令
     
     
      ,
     
     
      繼續
     
     
      Siwtch-Case
     
     
      的行為
     
     
      . Google
     
     
      文件中提到的另一種改善的技巧就是透過
     
     
      ”threaded execution”,
     
     
      在每個指令集
     
     
      OpCode
     
     
      執行結束後
     
     
      ,
     
     
      進行下一個指令集的
     
     
      fetch
     
     
      與
     
     
      dispatch,
     
     
      省去要回到迴圈啟始點
     
     
      (Branch)
     
     
      的固定成本
     
     
      .
     
    
    
     
     
    
    
     
      
      
      Dalvik
     
     
      直譯器的實作
     
     
      ,
     
     
      採用預先算好的
     
     
      Goto
     
     
      位址
     
     
      ,
     
     
      基於每個直譯器處理的指令集
     
     
      OpCode
     
     
      實作
     
     
      ,
     
     
      都固定以
     
     
      64bytes
     
     
      為
     
     
      Memory Alignment,
     
     
      取代得到一個指令集
     
     
      OpCode
     
     
      後
     
     
      ,
     
     
      要進行查表的成本
     
     
      ,
     
     
      只要取得
     
     
      OpCode
     
     
      後乘上
     
     
      64bytes(
     
     
      等於
     
     
      2
     
     
      的
     
     
      6
     
     
      次方
     
     
      ,
     
     
      可以透過
     
     
      Shift
     
     
      的方式運算
     
     
      ),
     
     
      就可以跳到對應指令集
     
     
      OpCode
     
     
      的實作
     
     
      .Android
     
     
      之所以選擇
     
     
      64bytes
     
     
      為每個指令集
     
     
      OpCode
     
     
      實作的最大空間
     
     
      ,
     
     
      並沒有特別的理由
     
     
      ,
     
     
      主要是這樣的值可以完全適用於目前
     
     
      Android
     
     
      對於
     
     
      ARM
     
     
      與
     
     
      x86
     
     
      上實作的結果
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      參考
     
     
      Source Code dalvik/libdex/OpCode.h
     
     
      中的
     
     
      DEFINE_GOTO_TABLE
     
     
      的宣告如下
     
     
      ,
     
    
    
     
      #define DEFINE_GOTO_TABLE(_name) /
     
    
    
     
      
      
      static const void* _name[kNumDalvikInstructions] = {
      
      
      /
     
    
    
     
      
      
      /* 00..0f */
      
      
      /
     
    
    
     
      
      
      H(OP_NOP),
      
      
      /
     
    
    
     
      
      
      H(OP_MOVE),
      
      
      /
     
    
    
     
      
      
      H(OP_MOVE_FROM16),
      
      
      /
     
    
    
     
      
      
      H(OP_MOVE_16),
      
      
      /
     
    
    
     
      
      
      H(OP_MOVE_WIDE),
      
      
      
      
      /
     
    
    
     
      
      
      H(OP_MOVE_WIDE_FROM16),
      
      
      /
     
    
    
     
      
      
      H(OP_MOVE_WIDE_16),
      
      
      /
     
    
    
     
      
      
      H(OP_MOVE_OBJECT),
      
      
      
      
      /
     
    
    
     
      
      
      H(OP_MOVE_OBJECT_FROM16),
      
      
      /
     
    
    
     
      .............................
     
    
    
     
      …....................................etc
     
    
    
     
     
    
    
     
      
      
     
     
      再參考
     
     
      Source Code dalvik/vm/mterp/cstubs/entry.c,
     
     
      有如下宣告
     
    
    
     
     
    
    
     
      /*
     
    
    
     
      
      
      * Handler function table, one entry per opcode.
     
    
    
     
      
      
      */
     
    
    
     
      #undef H
     
    
    
     
      #define H(_op) dvmMterp_##_op
     
    
    
     
      DEFINE_GOTO_TABLE(gDvmMterpHandlers)
     
    
    
     
      
      
     
    
    
     
      #undef H
     
    
    
     
      #define H(_op) #_op
     
    
    
     
      DEFINE_GOTO_TABLE(gDvmMterpHandlerNames)
     
    
    
     
     
    
    
     
      
      
     
     
      定義
     
     
      gDvmMterpHandlers
     
     
      對應到每個
     
     
      OpCode
     
     
      的處理實作
     
     
      ,
     
     
      與
     
     
      gDvmMterpHandlerNames
     
     
      對應到每個
     
     
      OpCode
     
     
      的名稱
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      再來追蹤函式
     
     
      bool dvmMterpStdRun(MterpGlue* glue) ,
     
     
      可以看到如下的
     
     
      Busy Loop
     
    
    
     
      while (true) {
     
    
    
     
      
      
      typedef void (*Handler)(MterpGlue* glue);
     
    
    
     
      
      
      
      
     
    
    
     
      
      
      u2 inst = /*glue->;*/pc[0];
     
    
    
     
      
      
      Handler handler = (Handler) gDvmMterpHandlers[inst & 0xff];
     
    
    
     
      
      
      LOGVV("handler %p %s/n",
     
    
    
     
      
      
      handler, (const char*) gDvmMterpHandlerNames[inst & 0xff]);
     
    
    
     
      
      
      (*handler)(glue);
     
    
    
     
      
      
      }
     
    
    
     
      
      
     
     
      會每次取一個
     
     
      Java
     
     
      指令集
     
     
      OpCode,
     
     
      並透過
     
     
      gDvmMterpHandlers
     
     
      對應
     
     
      0x00-0xff
     
     
      範圍的
     
     
      Java
     
     
      指令集
     
     
      OpCode
     
     
      的對應處理函式
     
     
      .
     
     
      在
     
     
      dalvik/vm/mterp/out/InterpAsm-<Arch>;.S
     
     
      中
     
     
      ,
     
     
      配合
     
     
      Fast Interpreter
     
     
      也有對應依據平台差異的函式
     
     
      dvmMterpStdRun
     
     
      組語版本實作
     
     
      ,
     
     
      跟
     
     
      C
     
     
      語言版本實作行為類似
     
     
      ,
     
     
      但最大的差異在於
     
     
      ,
     
     
      不是透過一個
     
     
      while(true)
     
     
      的
     
     
      Busy Loop
     
     
      去逐一抓取給
     
     
      Dalvik
     
     
      虛擬器的指令集
     
     
      ,
     
     
      而是先在函式
     
     
      dvmMterpStdRun
     
     
      中執行如下巨集
     
     
      (
     
     
      以
     
     
      InterpAsm-armv5te.S
     
     
      實作為例
     
     
      )
     
    
    
     
     
    
    
     
      
      
      FETCH_INST()
      
      
      @ load rINST from rPC
     
    
    
     
      
      
      GET_INST_OPCODE(ip)
      
      
      @ extract opcode from rINST
     
    
    
     
      
      
      GOTO_OPCODE(ip)
      
      
      @ jump to next instruction
     
    
    
     
     
    
    
     
      
      
     
     
      抓取第一個
     
     
      Dalvik OpCode
     
     
      指令並執行
     
     
      ,
     
     
      同時在每個指令執行結束後
     
     
      ,
     
     
      再透過
     
     
      FETCH_ADVANCE_INST
     
     
      與
     
     
      GET_INST_OPCODE
     
     
      抓取下一個
     
     
      Dalvik OpCode
     
     
      指令
     
     
      ,
     
     
      最後再透過
     
     
      GOTO_OPCODE
     
     
      執行該指令集的實作
     
     
      ,
     
     
      如此持續運作下去
     
     
      ,
     
     
      藉此得到比用
     
     
      C
     
     
      版本
     
     
      Busy Loop
     
     
      更高的執行效率
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      如果因為進行記憶體的
     
     
      Garbage Collection,
     
     
      進行除錯或是轉換到
     
     
      Native Code
     
     
      執行
     
     
      ,
     
     
      而讓執行中的
     
     
      Dalvik
     
     
      行程處於
     
     
      Suspend
     
     
      狀態
     
     
      ,Dalvik
     
     
      直譯器會提供一個安全機制
     
     
      ,
     
     
      確保行程可以被正確的回復執行
     
     
      .
     
     
      如下所示
     
     
      ,
     
     
      目前
     
     
      Dalvik
     
     
      主要支援
     
     
      Portable/Fast Interpreter,
     
     
      而
     
     
      Trace-JIT
     
     
      主要是屬於
     
     
      Fast-Interpreter
     
     
      實作中的一部分
     
     
      .
     
    
    
     
     
    
    
     
     
    
    
     
      
       
        
         
          Trace-JIT/Compiler
         
        
        
         
          
           (For Hot Fragments)
          
         
        
       
       
        
         
          Fast Interpreter
         
        
        
         
          
           (For Cold Fargments)
          
         
        
       
       
        
         
         
        
        
         
          Portable Interpreter
          
          (C Code)
         
        
       
      
      
       
        
         
          Fast Interpreter (ASM)
         
        
       
      
      
       
        
         
          
           Dalvik VM
          
         
        
       
      
     
    
    
     
     
    
    
     
     
    
    
     
      
      
      Dalvik
     
     
      上每一個應用程式不管是
     
     
      SDK
     
     
      或是
     
     
      NDK
     
     
      都會基於一個
     
     
      Java Based
     
     
      的應用程式為主體
     
     
      (NDK
     
     
      為
     
     
      Java+ELF .so),
     
     
      也因此要了解
     
     
      Android
     
     
      的應用程式
     
     
      Framework,
     
     
      最適當的途徑就是把
     
     
      Dalvik
     
     
      的運作原理與基礎做一個分析
     
     
      ,
     
     
      相對這會對於在
     
     
      Android
     
     
      架構下
     
     
      ,
     
     
      不管是開發應用程式或是進行系統的效能優化都會有相當的助益
     
     
      .
     
    
    
     
     
    
    
     
     
    
    
     
      
       Dalvik
      
     
     
      
       的控制與範例
      
     
     
     
    
    
     
     
    
    
     
      
      
     
     
      如果是透過
     
     
      PC
     
     
      上的系統參數設定操作
     
     
      ,
     
     
      可以透過
     
     
      adb
     
     
      設定如下的指令
     
    
    
     
      
      
      #
     
     
      設定系統參數
     
    
    
     
      
      
      adb shell setprop <name>; <value>;
     
    
    
     
      
      
      #
     
     
      取得系統參數
     
    
    
     
      
      
      adb shell getprop <name>;
     
    
    
     
      
      
     
     
      相關的
     
     
      Dalvik
     
     
      系統參數設定
     
     
      ,
     
     
      是在
     
     
      Zygote
     
     
      行程載入時進行初始化的
     
     
      ,
     
     
      一旦相關的系統參數被更動到
     
     
      ,
     
     
      就必須要重啟
     
     
      Dalvik Run-Time
     
     
      環境
     
     
      ,
     
     
      透過
     
     
      Zygote
     
     
      載入流程讓相關系統參數發揮作用
     
     
      .
     
    
    
     
      
      
     
     
      在開發階段
     
     
      ,
     
     
      有測試系統參數的需求時
     
     
      ,
     
     
      就可以藉由
     
     
      Android
     
     
      的
     
     
      Shell,
     
     
      透過
     
     
      Stop/Start
     
     
      指令
     
     
      ,
     
     
      終止與重啟
     
     
      Dalvik Run-Time
     
     
      環境
     
     
      ,
     
     
      讓系統參數發揮作用
     
     
      .(Stop
     
     
      會依序設定系統參數
     
     
     
     
      ctl.stop=runtime
     
     
      與
     
     
      ctl.stop=zygote,Start
     
     
      會依序設定系統參數
     
     
      ctl.start=zygote
     
     
      與
     
     
      ctl.start=runtime)
     
    
    
     
      
      
     
    
    
     
     
    
    
     
     
    
    
     
      
       
        
         
          系統參數
         
        
       
       
        
         
          值
         
        
       
       
        
         
          說明
         
        
       
      
      
       
        
         
          dalvik.vm.stack-trace-file
         
        
       
       
        
         
          /data/anr/traces.txt
         
        
       
       
        
         
          Stack Dumps
          
         
         
          範例
         
         
          :
         
         
          setprop dalvik.vm.stack-trace-file /tmp/stack-traces.txt
         
        
        
         
         
        
        
         
          Dalvik
         
         
          虛擬器在收到
         
         
         
         
          Linux Signal SIGQUIT (
         
         
          也可透過
         
         
          kill -3
         
         
          觸發
         
         
          )
         
         
          就會把目標行程所有執行緒的
         
         
          Stack Traces
         
         
          內容
         
         
          (
         
         
          可以知道每個執行緒函式呼叫的
         
         
          Call Stack),
         
         
          根據這個參數指定的路徑把資料寫入
         
         
          ,
         
         
          供開發者分析問題時參考之用
         
         
          .
         
        
       
      
      
       
        
         
          dalvik.vm.dexopt-flags
         
        
       
       
        
         
          m=y
         
        
       
       
        
         
          Bytecode Verification and Optimization
         
        
        
         
          範例
         
         
          :
         
         
          setprop dalvik.vm.dexopt-flags v=a,o=v
         
        
        
         
          用來決定
         
         
          dexopt
         
         
          所進行執行前的驗證與最佳化動作的行為
         
         
          ,
         
         
          在實際的裝置上
         
         
          ,dexopt
         
         
          會在
         
         
          Dalvik
         
         
          啟動一個應用或是應用程式安裝時調用
         
         
          (
         
         
          會透過
         
         
          dexlock
         
         
          確保同時只有一個被執行到
         
         
          ),
         
        
        
         
          進一步說明參數如下
         
        
        
         
          v=a,o=v =>;
         
         
          驗證所有的
         
         
          Dex
         
         
          檔案
         
         
          ,
         
         
          並且只最佳化被驗證過的
         
         
          Dex
         
         
          檔案
         
         
          ,
         
         
          如果驗證失敗
         
         
          ,
         
         
          該
         
         
          Dex
         
         
          檔案就不會被執行
         
        
        
         
          v=n,o=v =>;
         
         
          關閉驗證
         
         
          Dex
         
         
          的動作
         
         
          ,
         
         
          只針對有被驗證過的
         
         
          Dex
         
         
          進行最佳化
         
         
          ,
         
         
          沒被驗證過的
         
         
          Dex,
         
         
          就會直接執行
         
         
          (
         
         
          也不會被最佳化
         
         
          )
         
        
        
         
         
        
        
         
          根據
         
         
          Android
         
         
          的文件
         
         
          ,
         
         
          第一次執行的
         
         
          Dex
         
         
          檔案
         
         
          ,
         
         
          進行驗證的動作
         
         
          ,
         
         
          可能會讓執行時間慢了
         
         
          40%
         
         
          左右
         
         
          ,
         
         
          但只要該
         
         
          Dex
         
         
          檔案有驗證過
         
         
          ,
         
         
          並且對應放在
         
         
          dalvik-cache
         
         
          下
         
         
          ,
         
         
          只要該檔案沒有變動且所相依的其他
         
         
          Dex
         
         
          檔案也沒有更動過
         
         
          ,
         
         
          之後執行就可省去驗證的流程
         
         
          ,
         
         
          並可透過最佳化機制
         
         
          ,
         
         
          加速應用程式的啟動執行
         
         
          .
         
        
        
         
          Enabling type-precise GC results in larger optimized DEX files.
          
          
          The additional storage requirements for ".odex" files can cause /system to overflow on some devices, so this is configured separately for each product.
         
        
       
      
      
       
        
         
          dalvik.vm.lockprof.threshold
         
        
       
       
        
         
          500
         
        
       
       
        
         
          Enable Dalvik lock contention logging for userdebug builds.
         
        
       
      
      
       
        
         
          dalvik.vm.checkjni
          
          
         
        
       
       
        
         
          true/false
         
        
       
       
        
         
          Extended JNI Checks
         
        
        
         
          範例
         
         
          :setprop dalvik.vm.checkjni true
         
        
        
         
          如果系統沒有設置
         
         
         
         
          dalvik.vm.checkjni,
         
         
          就會以
         
         
         
         
          ro.kernel.android.checkjni
         
         
          為主
         
         
          ,
         
         
          如果有設置
         
         
         
         
          dalvik.vm.checkjni(
         
         
          不論是
         
         
          true
         
         
          或
         
         
          false),
         
         
          則以
         
         
         
         
          dalvik.vm.checkjni
         
         
          為依據來決定
         
         
          CheckJNI
         
         
          的開或關
         
        
        
         
          另一個對應的參數為
         
         
         
         
          ro.kernel.android.checkjni,
         
         
          可在編譯時期透過
         
         
          build/core/main.mk
         
         
          決定
         
         
          .
         
        
        
         
         
        
        
         
          這參數的設置
         
         
          ,
         
         
          會讓
         
         
          JNI
         
         
          函式呼叫前
         
         
          ,
         
         
          執行相關的稽核動作
         
         
          ,
         
         
          其中包括
         
        
        
         
          1,
         
         
          查核
         
         
          NULL Pointer
         
        
        
         
          2,
         
         
          查核函式參數的正確性
         
         
         
         
          (jclass is a class object, jfieldID points to field data, jstring is a java.lang.String)
         
        
        
         
          3,
         
         
          確認資料寫入動作與變數宣告一致
         
         
          . (
         
         
          例如
         
         
          : don't store a HashMap in a String field.)
         
        
        
         
          4,
         
         
          確認是否有不允許的例外處理有因為函式呼叫正在等待例外的情況
         
         
          .
         
        
        
         
          5,
         
         
          確認關鍵的
         
         
          Get/Release
         
         
          呼叫沒有不適當的函式存在
         
        
        
         
          6,
         
         
          確認
         
         
          JNIEnv
         
         
          不會被跨執行緒
         
         
          (Thread)
         
         
          分享
         
        
        
         
          7,
         
         
          確認
         
         
          Local
         
         
          變數的參考不會超過該變數所能支援的變數壽命週期
         
         
          .
         
        
        
         
          8,UTF-8
         
         
          字串只會包含有效修改的
         
         
          UTF-8
         
         
          資料
         
         
          .
         
        
       
      
      
       
        
         
          dalvik.vm.jniopts
         
        
       
       
        
         
          forcecopy
         
        
       
       
        
         
          Extended JNI Checks
         
        
        
         
          範例
         
         
          :setprop dalvik.vm.jniopts forcecopy
         
        
        
         
         
        
        
         
         
        
       
      
      
       
        
         
          
           dalvik.vm.enableassertions
          
         
        
       
       
        
         
          You can provide a class name, a package name (followed by "..."), or the special value "all"
         
        
       
       
        
         
          Assertions
         
        
        
         
          範例
         
         
          :
         
         
          setprop dalvik.vm.enableassertions all
         
        
        
         
         
        
        
         
          Dalvik
         
         
          虛擬器預設對於
         
         
          Assertion
         
         
          是關閉的
         
         
          ,
         
         
          可以透過設定這個參數來開關
         
         
          Dalvik
         
         
          上
         
         
          Java
         
         
          程式碼
         
         
          Assertion
         
         
          的動作
         
         
          ,
         
        
       
      
      
       
        
         
          dalvik.vm.execution-mode
         
        
       
       
        
         
          int:portable/int:fast/int:jit
         
        
       
       
        
         
          Execution Mode
         
        
        
         
          範例
         
         
          :
         
        
        
         
          setprop dalvik.vm.execution-mode int:portable (C
         
         
          版本的
         
         
          Intepreter)
         
        
        
         
          setprop dalvik.vm.execution-mode int:fast (
         
         
          組語版本的
         
         
          Intepreter)
         
        
        
         
          setprop dalvik.vm.execution-mode int:jit (Just-in Time
         
         
          加速
         
         
          )
         
        
        
         
         
        
        
         
          如果有啟動
         
         
          Profiling
         
         
          或是接上
         
         
          Java
         
         
          除錯器
         
         
          ,
         
         
          就會切到
         
         
          Debug Mode(
         
         
          我理解
         
         
          Debug Mode
         
         
          是在
         
         
         
         
          C
         
         
          版本的
         
         
          Portable Intepreter
         
         
          中支援的
         
         
          ),
         
         
          當除錯階段結束
         
         
          ,
         
         
          或是
         
         
          Profiling
         
         
          結束
         
         
          ,
         
         
          就會重新回復原本執行的
         
         
          Java
         
         
          模式
         
         
          .
         
        
        
         
         
        
        
         
          如果在
         
         
          
           AndroidManifest.xml
          
         
         
          
           中把
          
         
         
          
           android:vmSafeMode
          
         
         
          
           設定為
          
         
         
          
           true,
          
         
         
          
           就會預設關閉
          
         
         
          
           JIT
          
         
         
          
           選項
          
         
         
          
           ,
          
         
         
          
           開發者可借此釐清應用程式所造成的問題
          
         
         
          
           ,
          
         
         
          
           是否為
          
         
         
          
           JIT
          
         
         
          
           所導致的
          
         
         
          
           .
          
         
        
       
      
      
       
        
         
          dalvik.vm.deadlock-predict err
         
        
       
       
        
         
          off/warn/err
         
        
       
       
        
         
          Deadlock Prediction
         
        
        
         
          範例
         
         
          :
         
         
          setprop dalvik.vm.deadlock-predict err
         
        
        
         
         
        
        
         
          編譯
         
         
          Dalvik
         
         
          時必須要加上
         
         
         
         
          
           WITH_DEADLOCK_PREDICTION
          
         
         
          
           便能支援這個功能
          
         
         
          
           ,
          
         
         
          
           參考
          
         
         
          
           Android
          
         
         
          
           文件
          
         
         
          
           ,
          
         
         
          
           這機制主要用來進行
          
         
         
          
           Dalvik
          
         
         
          
           上
          
         
         
          
           Deadlock
          
         
         
          
           的預測
          
         
         
          
           ,
          
         
         
          
           而非偵測
          
         
        
        
         
         
        
        
         
          
           如果設定為
          
         
         
          
           off
          
         
         
          
           就是關閉
          
         
         
          
           ,warn
          
         
         
          
           是記錄這個問題
          
         
         
          
           ,
          
         
         
          
           但程式繼續執行
          
         
         
          
           ,
          
         
         
          
           如果是
          
         
         
          
           err
          
         
         
          
           就是在
          
         
         
          
           Dalvik OpCpde OP_MONITOR_ENTER(0x1d)
          
         
         
          
           指令執行完畢後
          
         
         
          
           ,
          
         
         
          
           立刻觸發
          
         
         
          
           Exception,
          
         
         
          
           終止
          
         
         
          
           Dalvik
          
         
         
          
           虛擬器的執行
          
         
         
          
           .
          
         
        
       
      
      
       
        
         
          dalvik.vm.check-dex-sum
         
        
       
       
        
         
         
        
       
       
        
         
          DEX File Checksums
          
         
         
          範例
         
         
          :
         
         
          setprop dalvik.vm.check-dex-sum true
         
        
        
         
          目前
         
         
          Dalvik
         
         
          虛擬器預設對載入
         
         
          ODEX(Optimized DEX)
         
         
          的流程
         
         
          ,
         
         
          是不做
         
         
          Checksum
         
         
          確保的
         
         
          ,
         
         
          參考
         
         
          dalvik-cache,
         
         
          跟系統與
         
         
          Framework
         
         
          有關的
         
         
          ODEX,
         
         
          所
         
         
          Owner
         
         
          與
         
         
          Group
         
         
          會是
         
         
          root
         
         
          或
         
         
          system,
         
         
          只有一般應用執行的
         
         
          ODEX,
         
         
          會把
         
         
          Group
         
         
          設定為對應的
         
         
          AP Group,
         
         
          基於此
         
         
          ,Android
         
         
          預設透過系統存取權限的保護
         
         
          ,
         
         
          就可以防止
         
         
          ODEX
         
         
          檔案被修改的可能
         
         
          .
         
        
        
         
          如果所在的儲存媒體不可靠
         
         
          ,
         
         
          容易有資料損毀的問題發生
         
         
          ,
         
         
          就會有必要加入
         
         
          Checksum
         
         
          的機制
         
         
          (
         
         
          其實以目前很多
         
         
          SmartPhone
         
         
          用
         
         
         
         
          MLC NAND+FTL Controller
         
         
          的組合
         
         
          ,
         
         
          只要
         
         
          Wear-Leveling
         
         
          有作用
         
         
          ,
         
         
          要遇到儲存裝置的
         
         
          ”
         
         
          不可靠
         
         
          ”,
         
         
          對一般使用者而言
         
         
          ,
         
         
          應該是很不容易遇到
         
         
          ).
         
         
          開發階段
         
         
          ,
         
         
          也可以透過
         
         
          dexdump
         
         
          工具
         
         
          ,
         
         
          手動的確認
         
         
          DEX
         
         
          檔案的
         
         
          Checksum.
         
        
       
      
      
       
        
         
          dalvik.vm.jit.profile
         
        
       
       
        
         
          true/false
         
        
       
       
        
         
          JIT Profile
          
         
         
          範例
         
         
          :
         
         
          setprop dalvik.vm.jit.profile true
         
        
        
         
          可以用來查看
         
         
          Dalvik JIT
         
         
          對於熱門執行區塊的統計資訊
         
         
          .
         
        
       
      
     
    
    
     
     
    
    
     
     
    
    
     
     
    
    
     
      
       有關
      
     
     
      
       Dalvik
      
     
     
      
       行程與執行時期介紹
      
     
     
     
    
    
     
     
    
    
     
      
      
     
     
      如下所示
     
     
      ,
     
     
      為
     
     
      Android
     
     
      系統應用程式啟動的父子行程關係
     
     
      ,
     
     
      我們可以看到
     
     
      init
     
     
      會把包括
     
     
      Service Manager,Netd,Rild,MediaServer,BootAnimation
     
     
      這些原生行程載入
     
     
      ,
     
     
      而
     
     
      Dalvik
     
     
      的第一個初始化程式會透過
     
     
      app_process
     
     
      載入後
     
     
      ,
     
     
      並命名為
     
     
      Zygote(
     
     
      ㄟ
     
     
     
     
      ...Google
     
     
      翻譯查詢是
     
     
     
     
      "
     
     
      受精卵
     
     
      "),
     
     
      再由
     
     
      Zygote
     
     
      帶起
     
     
      system_server
     
     
      與後續的
     
     
      Dalvik
     
     
      應用程式
     
     
      .
     
    
    
     
     
    
    
     
     
    
    
     
      
       
        
         
          Kernel(PID=0)
         
        
       
      
      
       
        
         
         
        
       
       
        
         
          /init(PID=1)
         
        
       
       
        
         
          /system/bin/sh(PID=27)
         
        
        
         
          /system/bin/servicemanager(PID=28)
         
        
        
         
          /system/bin/vold(PID=29)
         
        
        
         
          /system/bin/netd(PID=30)
         
        
        
         
          /system/bin/debuggerd(PID=31)
         
        
        
         
          /system/bin/rild(PID=32)
         
        
        
         
          /system/bin/mediaserver(PID=34)
         
        
        
         
          /system/bin/dbus-daemon(PID=35)
         
        
        
         
          /system/bin/installd(PID=36)
         
        
        
         
          /system/bin/keystore(PID=37)
         
        
        
         
          /system/bin/sh(PID=38)
         
        
        
         
          /system/bin/qemud(PID=39)
         
        
        
         
          /sbin/adbd(PID=41)
         
        
        
         
          /system/bin/bootanimation(PID=81)
         
        
       
      
      
       
        
         
          zygote(PID=33)
         
        
       
       
        
         
          system_server (pid:74)
          
          com.android.inputmethod.latin (pid:146)
          
          com.android.phone (pid:150)
          
          android.process.acore (pid:189)
          
          com.android.launcher (pid:191)
          
          com.android.quicksearchbox (pid:229)
          
          android.process.media (pid:259)
          
          com.android.bluetooth (pid:273)
          
          com.android.providers.calendar (pid:280)
          
          com.android.email (pid:292)
          
          com.android.mms (pid:305)
          
          com.android.protips (pid:323)
          
          com.android.music (pid:329)
          
          com.cooliris.media (pid:335)
         
        
       
      
      
       
        
         
          kthreadd(PID=2)
         
        
       
       
        
         
          ksoftirqd/0(PID=3)
         
        
        
         
          events/0(PID=4)
         
        
        
         
          khelper(PID=5)
         
        
        
         
          suspend(PID=6)
         
        
        
         
          kblockd/0(PID=7)
         
        
        
         
          cqueue(PID=8)
         
        
        
         
          kseriod(PID=9)
         
        
        
         
          kmmcd(PID=10)
         
        
        
         
          pdflush(PID=11)
         
        
        
         
          pdflush(PID=12)
         
        
        
         
          kswapd0(PID=13)
         
        
        
         
          aio/0(PID=14)
         
        
        
         
          mtdblockd(PID=22)
         
        
        
         
          kstriped(PID=23)
         
        
        
         
          hid_compat(PID=24)
         
        
        
         
          rpciod/0(PID=25)
         
        
        
         
          mmcqd(PID=26)
         
        
       
      
     
    
    
     
     
    
    
     
     
    
    
     
     
    
    
     
      
      
     
     
      以目前筆者環境
     
     
      ,
     
     
      列舉一個
     
     
      Dalvik
     
     
      應用程式
     
     
      CalendarProvider
     
     
      的記憶體
     
     
      Mapping
     
     
      資訊
     
     
      .
     
     
      對應到其他
     
     
      Dalvik
     
     
      應用程式
     
     
      ,
     
     
      我們可以看到基於
     
     
      Apriori prelink
     
     
      機制
     
     
      ,
     
     
      在共用原生碼動態函式庫
     
     
      .so
     
     
      的部份
     
     
      ,
     
     
      不同的
     
     
      Dalvik
     
     
      應用程式
     
     
      ,
     
     
      也會對應到同樣的記憶體位置
     
     
      .
     
     
      而在
     
     
      Dalvik OpCpde
     
     
      編碼動態函式庫有共用的
     
     
      .jar (
     
     
      會被解開為
     
     
     
     
      classes.dex)
     
     
      部分
     
     
      ,
     
     
      在跨不同的
     
     
      Dalvik
     
     
      應用程式
     
     
      ,
     
     
      會被配置到同樣的記憶體位址
     
     
      .
     
    
    
     
     
    
    
     
     
    
    
     
     
    
    
     
      
       
        
         
          記憶體位址
         
        
       
       
        
         
          屬性
         
        
       
       
        
         
          對應的執行檔或是函式庫名稱
         
        
       
      
      
       
        
         
          00008000-00009000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/bin/app_process
         
        
       
      
      
       
        
         
          00009000-0000a000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/bin/app_process
         
        
       
      
      
       
        
         
          0000a000-001f9000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          [heap]
         
        
       
      
      
       
        
         
          40000000-40008000
         
        
       
       
        
         
          r-xs
         
        
       
       
        
         
          /dev/ashmem/system_properties
         
        
       
      
      
       
        
         
          40008000-40009000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          40009000-4024a000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /dev/ashmem/mspace/dalvik-heap/zygote/0
         
        
       
      
      
       
        
         
          4024a000-41009000
         
        
       
       
        
         
          ---p
         
        
       
       
        
         
          /dev/ashmem/mspace/dalvik-heap/zygote/0
         
        
       
      
      
       
        
         
          41009000-41038000
         
        
       
       
        
         
          r-xs
         
        
       
       
        
         
          /system/fonts/DroidSans.ttf
         
        
       
      
      
       
        
         
          41038000-4104c000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          4104c000-4104d000
         
        
       
       
        
         
          ---p
         
        
       
       
        
         
          /dev/ashmem/dalvik-LinearAlloc
         
        
       
      
      
       
        
         
          4104d000-41254000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /dev/ashmem/dalvik-LinearAlloc
         
        
       
      
      
       
        
         
          41254000-4154c000
         
        
       
       
        
         
          ---p
         
        
       
       
        
         
          /dev/ashmem/dalvik-LinearAlloc
         
        
       
      
      
       
        
         
          4154c000-4175b000
         
        
       
       
        
         
          r-xs
         
        
       
       
        
         
          /system/framework/core.jar
         
        
       
      
      
       
        
         
          4175b000-41c23000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /data/dalvik-cache/system@framework@core.jar@classes.dex
         
        
       
      
      
       
        
         
          41c23000-41c68000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          41c68000-41ca2000
         
        
       
       
        
         
          r-xs
         
        
       
       
        
         
          /system/framework/ext.jar
         
        
       
      
      
       
        
         
          41ca2000-41d2e000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /data/dalvik-cache/system@framework@ext.jar@classes.dex
         
        
       
      
      
       
        
         
          41d2e000-41fc5000
         
        
       
       
        
         
          r-xs
         
        
       
       
        
         
          /system/framework/framework.jar
         
        
       
      
      
       
        
         
          41fc5000-425f2000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /data/dalvik-cache/system@framework@framework.jar@classes.dex
         
        
       
      
      
       
        
         
          425f2000-42676000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          42676000-4268b000
         
        
       
       
        
         
          r-xs
         
        
       
       
        
         
          /system/framework/android.policy.jar
         
        
       
      
      
       
        
         
          4268b000-426b9000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /data/dalvik-cache/system@framework@android.policy.jar@classes.dex
         
        
       
      
      
       
        
         
          426b9000-42752000
         
        
       
       
        
         
          r-xs
         
        
       
       
        
         
          /system/framework/services.jar
         
        
       
      
      
       
        
         
          42752000-428a0000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /data/dalvik-cache/system@framework@services.jar@classes.dex
         
        
       
      
      
       
        
         
          428a0000-428a3000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          428a3000-428d9000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /dev/ashmem/dalvik-heap-bitmap/objects
         
        
       
      
      
       
        
         
          428d9000-428df000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          428df000-428e0000
         
        
       
       
        
         
          r-xs
         
        
       
       
        
         
          /dev/ashmem/SurfaceFlinger read-only heap
         
        
       
      
      
       
        
         
          428e0000-42907000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          42907000-4290c000
         
        
       
       
        
         
          r-xs
         
        
       
       
        
         
          
           /system/app/CalendarProvider.apk
          
         
        
       
      
      
       
        
         
          4291a000-4294b000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          4294b000-42982000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /dev/ashmem/dalvik-heap-bitmap/mark/0
         
        
       
      
      
       
        
         
          42982000-429c2000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /dev/ashmem/dalvik-heap-bitmap/mark/1
         
        
       
      
      
       
        
         
          
           429c2000-42a16000
          
         
        
       
       
        
         
          r-xs
         
        
       
       
        
         
          
           /system/app/CalendarProvider.apk
          
         
        
       
      
      
       
        
         
          42a16000-42a29000
         
        
       
       
        
         
          r-xs
         
        
       
       
        
         
          /system/framework/android.test.runner.jar
         
        
       
      
      
       
        
         
          42a29000-42a55000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /data/dalvik-cache/system@framework@android.test.runner.jar@classes.dex
         
        
       
      
      
       
        
         
          42a70000-42e23000
         
        
       
       
        
         
          r-xs
         
        
       
       
        
         
          /system/framework/framework-res.apk
         
        
       
      
      
       
        
         
          42e23000-4304e000
         
        
       
       
        
         
          r-xs
         
        
       
       
        
         
          /system/framework/framework-res.apk
         
        
       
      
      
       
        
         
          4304e000-4308f000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /dev/ashmem/mspace/dalvik-heap/zygote/1
         
        
       
      
      
       
        
         
          4308f000-43e0e000
         
        
       
       
        
         
          ---p
         
        
       
       
        
         
          /dev/ashmem/mspace/dalvik-heap/zygote/1
         
        
       
      
      
       
        
         
          43e0e000-43e4f000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /dev/ashmem/mspace/dalvik-heap/2
         
        
       
      
      
       
        
         
          43e4f000-44b8e000
         
        
       
       
        
         
          ---p
         
        
       
       
        
         
          /dev/ashmem/mspace/dalvik-heap/2
         
        
       
      
      
       
        
         
          44b8e000-44b8f000
         
        
       
       
        
         
          ---p
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          44b8f000-44c8e000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          44c8e000-44c8f000
         
        
       
       
        
         
          ---p
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          44c8f000-44d8e000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          44d8e000-44e8c000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /dev/binder
         
        
       
      
      
       
        
         
          44e8c000-44e8d000
         
        
       
       
        
         
          ---p
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          44e8d000-44f8c000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          44f8c000-44f8d000
         
        
       
       
        
         
          ---p
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          44f8d000-4508c000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          
           4508c000-450e0000
          
         
        
       
       
        
         
          r-xs
         
        
       
       
        
         
          
           /system/app/CalendarProvider.apk
          
         
        
       
      
      
       
        
         
          450e0000-451ab000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /data/dalvik-cache/system@app@CalendarProvider.apk@classes.dex
         
        
       
      
      
       
        
         
          80000000-801d0000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libicudata.so
         
        
       
      
      
       
        
         
          801d0000-801d1000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libicudata.so
         
        
       
      
      
       
        
         
          80200000-80286000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libdvm.so
         
        
       
      
      
       
        
         
          80286000-80289000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libdvm.so
         
        
       
      
      
       
        
         
          80289000-8028a000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          9d100000-9d139000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libstlport.so
         
        
       
      
      
       
        
         
          9d139000-9d13b000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libstlport.so
         
        
       
      
      
       
        
         
          9d700000-9d736000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libjpeg.so
         
        
       
      
      
       
        
         
          9d736000-9d737000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libjpeg.so
         
        
       
      
      
       
        
         
          9ea00000-9ea08000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libdrm1.so
         
        
       
      
      
       
        
         
          9ea08000-9ea09000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libdrm1.so
         
        
       
      
      
       
        
         
          a2f00000-a2fa9000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libstagefright.so
         
        
       
      
      
       
        
         
          a2fa9000-a2fac000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libstagefright.so
         
        
       
      
      
       
        
         
          a3500000-a3503000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libstagefright_color_conversion.so
         
        
       
      
      
       
        
         
          a3503000-a3504000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libstagefright_color_conversion.so
         
        
       
      
      
       
        
         
          a3600000-a3605000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libstagefright_avc_common.so
         
        
       
      
      
       
        
         
          a3605000-a3606000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libstagefright_avc_common.so
         
        
       
      
      
       
        
         
          a3700000-a370c000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libstagefright_amrnb_common.so
         
        
       
      
      
       
        
         
          a370c000-a370d000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libstagefright_amrnb_common.so
         
        
       
      
      
       
        
         
          a3900000-a39c7000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libopencore_common.so
         
        
       
      
      
       
        
         
          a39c7000-a39cd000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libopencore_common.so
         
        
       
      
      
       
        
         
          a4800000-a48b6000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libopencore_player.so
         
        
       
      
      
       
        
         
          a48b6000-a48be000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libopencore_player.so
         
        
       
      
      
       
        
         
          a5900000-a5917000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libomx_amrenc_sharedlibrary.so
         
        
       
      
      
       
        
         
          a5917000-a5918000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libomx_amrenc_sharedlibrary.so
         
        
       
      
      
       
        
         
          a6800000-a682f000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libopencore_net_support.so
         
        
       
      
      
       
        
         
          a682f000-a6832000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libopencore_net_support.so
         
        
       
      
      
       
        
         
          a6d00000-a6d14000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libomx_sharedlibrary.so
         
        
       
      
      
       
        
         
          a6d14000-a6d15000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libomx_sharedlibrary.so
         
        
       
      
      
       
        
         
          a7500000-a7502000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libemoji.so
         
        
       
      
      
       
        
         
          a7502000-a7503000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libemoji.so
         
        
       
      
      
       
        
         
          a7e00000-a7e05000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libhardware_legacy.so
         
        
       
      
      
       
        
         
          a7e05000-a7e06000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libhardware_legacy.so
         
        
       
      
      
       
        
         
          a7f00000-a7f01000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libhardware.so
         
        
       
      
      
       
        
         
          a7f01000-a7f02000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libhardware.so
         
        
       
      
      
       
        
         
          a8100000-a8124000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libutils.so
         
        
       
      
      
       
        
         
          a8124000-a8125000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libutils.so
         
        
       
      
      
       
        
         
          a8200000-a821f000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libbinder.so
         
        
       
      
      
       
        
         
          a821f000-a8225000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libbinder.so
         
        
       
      
      
       
        
         
          a8300000-a86ec000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libwebcore.so
         
        
       
      
      
       
        
         
          a86ec000-a8747000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libwebcore.so
         
        
       
      
      
       
        
         
          a8747000-a8749000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          a8a00000-a8a14000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libexpat.so
         
        
       
      
      
       
        
         
          a8a14000-a8a16000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libexpat.so
         
        
       
      
      
       
        
         
          a8b00000-a8b4d000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libsqlite.so
         
        
       
      
      
       
        
         
          a8b4d000-a8b4f000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libsqlite.so
         
        
       
      
      
       
        
         
          a9000000-a9051000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libmedia.so
         
        
       
      
      
       
        
         
          a9051000-a905d000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libmedia.so
         
        
       
      
      
       
        
         
          a9300000-a930c000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libmedia_jni.so
         
        
       
      
      
       
        
         
          a930c000-a930d000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libmedia_jni.so
         
        
       
      
      
       
        
         
          a9400000-a941c000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libvorbisidec.so
         
        
       
      
      
       
        
         
          a941c000-a941d000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libvorbisidec.so
         
        
       
      
      
       
        
         
          a9500000-a9552000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libsonivox.so
         
        
       
      
      
       
        
         
          a9552000-a9553000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libsonivox.so
         
        
       
      
      
       
        
         
          a9553000-a9554000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          a9c00000-a9c0a000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libskiagl.so
         
        
       
      
      
       
        
         
          a9c0a000-a9c0b000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libskiagl.so
         
        
       
      
      
       
        
         
          ab100000-ab211000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libskia.so
         
        
       
      
      
       
        
         
          ab211000-ab215000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libskia.so
         
        
       
      
      
       
        
         
          ab215000-ab218000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          ab900000-ab912000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libui.so
         
        
       
      
      
       
        
         
          ab912000-ab914000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libui.so
         
        
       
      
      
       
        
         
          aba80000-aba90000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libcamera_client.so
         
        
       
      
      
       
        
         
          aba90000-aba93000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libcamera_client.so
         
        
       
      
      
       
        
         
          abb00000-abb09000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libexif.so
         
        
       
      
      
       
        
         
          abb09000-abb0a000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libexif.so
         
        
       
      
      
       
        
         
          abb0a000-abb0c000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          abd00000-abd02000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libETC1.so
         
        
       
      
      
       
        
         
          abd02000-abd03000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libETC1.so
         
        
       
      
      
       
        
         
          abe00000-abe08000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libEGL.so
         
        
       
      
      
       
        
         
          abe08000-abe09000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libEGL.so
         
        
       
      
      
       
        
         
          abe09000-abe0b000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          ac100000-ac104000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libGLESv2.so
         
        
       
      
      
       
        
         
          ac104000-ac105000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libGLESv2.so
         
        
       
      
      
       
        
         
          ac200000-ac205000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libGLESv1_CM.so
         
        
       
      
      
       
        
         
          ac205000-ac206000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libGLESv1_CM.so
         
        
       
      
      
       
        
         
          ac700000-ac715000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libsurfaceflinger_client.so
         
        
       
      
      
       
        
         
          ac715000-ac718000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libsurfaceflinger_client.so
         
        
       
      
      
       
        
         
          ac900000-ac919000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libpixelflinger.so
         
        
       
      
      
       
        
         
          ac919000-ac91b000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libpixelflinger.so
         
        
       
      
      
       
        
         
          ad100000-ad12f000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libnativehelper.so
         
        
       
      
      
       
        
         
          ad12f000-ad132000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libnativehelper.so
         
        
       
      
      
       
        
         
          ad300000-ad36d000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libandroid_runtime.so
         
        
       
      
      
       
        
         
          ad36d000-ad375000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libandroid_runtime.so
         
        
       
      
      
       
        
         
          ad375000-ad37a000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          ad900000-ad9e0000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libicui18n.so
         
        
       
      
      
       
        
         
          ad9e0000-ad9e4000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libicui18n.so
         
        
       
      
      
       
        
         
          ad9e4000-ad9e5000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          ade00000-aded0000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libicuuc.so
         
        
       
      
      
       
        
         
          aded0000-aded8000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libicuuc.so
         
        
       
      
      
       
        
         
          aded8000-adeda000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          ae300000-ae304000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libnetutils.so
         
        
       
      
      
       
        
         
          ae304000-ae305000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libnetutils.so
         
        
       
      
      
       
        
         
          ae400000-ae402000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libwpa_client.so
         
        
       
      
      
       
        
         
          ae402000-ae403000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libwpa_client.so
         
        
       
      
      
       
        
         
          af000000-af08d000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libcrypto.so
         
        
       
      
      
       
        
         
          af08d000-af09f000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libcrypto.so
         
        
       
      
      
       
        
         
          af09f000-af0a1000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          af400000-af424000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libssl.so
         
        
       
      
      
       
        
         
          af424000-af427000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libssl.so
         
        
       
      
      
       
        
         
          af700000-af713000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libz.so
         
        
       
      
      
       
        
         
          af713000-af714000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libz.so
         
        
       
      
      
       
        
         
          af900000-af90e000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libcutils.so
         
        
       
      
      
       
        
         
          af90e000-af90f000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libcutils.so
         
        
       
      
      
       
        
         
          af90f000-af91e000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          afa00000-afa03000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/liblog.so
         
        
       
      
      
       
        
         
          afa03000-afa04000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/liblog.so
         
        
       
      
      
       
        
         
          afb00000-afb20000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libm.so
         
        
       
      
      
       
        
         
          afb20000-afb21000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libm.so
         
        
       
      
      
       
        
         
          afc00000-afc01000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libstdc++.so
         
        
       
      
      
       
        
         
          afc01000-afc02000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libstdc++.so
         
        
       
      
      
       
        
         
          afd00000-afd3f000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/lib/libc.so
         
        
       
      
      
       
        
         
          afd3f000-afd42000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/lib/libc.so
         
        
       
      
      
       
        
         
          afd42000-afd4d000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          b0001000-b000c000
         
        
       
       
        
         
          r-xp
         
        
       
       
        
         
          /system/bin/linker
         
        
       
      
      
       
        
         
          b000c000-b000d000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          /system/bin/linker
         
        
       
      
      
       
        
         
          b000d000-b0016000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          bea87000-bea9c000
         
        
       
       
        
         
          rwxp
         
        
       
       
        
         
          [stack]
         
        
       
      
      
       
        
         
         
        
       
       
        
         
         
        
       
       
        
         
         
        
       
      
      
       
        
         
         
        
       
       
        
         
         
        
       
       
        
         
         
        
       
      
      
       
        
         
          0xc0000000---------
         
        
       
       
        
         
         
        
       
       
        
         
          LINUX KERNEL
         
        
       
      
      
       
        
         
         
        
       
       
        
         
         
        
       
       
        
         
         
        
       
      
     
    
    
     
     
    
    
     
     
    
    
     
      
       使用
      
     
     
      
      
     
     
      
       ANT
      
     
     
      
       包裝
      
     
     
      
       NDK
      
     
     
      
       應用程式為
      
     
     
      
       APK
      
     
    
    
     
     
    
    
     
      
      
      Java
     
     
      的應用
     
     
      ,
     
     
      通常可以透過
     
     
      Ant
     
     
      來包裝動態函式庫
     
     
      .so
     
     
      檔案與
     
     
      Java
     
     
      應用程式為
     
     
      .apk,Ant
     
     
      是一個
     
     
      Apache
     
     
      計畫的產物
     
     
      ,
     
     
      官方網站為
     
     
      
       http://ant.apache.org/
      
      ,
     
     
      下載
     
     
      JUnit
      
       https://github.com/KentBeck/junit/downloads
      
      
      
      (
     
     
      筆者下載的路徑是
     
     
      http://cloud.github.com/downloads/KentBeck/junit/junit-4.9b2.jar),
     
     
      把
     
     
     
     
      junit-4.9b2.jar
     
     
      複製到
     
     
     
     
      ant
     
     
      解開後的路徑
     
     
      
      
      lib/optional
     
     
      下
     
     
      ,
     
     
      然後如下設定環境變數
     
    
    
     
     
    
    
     
      (
      
       http://ant.apache.org/manual/index.html
      
      )
     
    
    
     
      
       export ANT_HOME=/usr/local/ant
      
     
    
    
     
      
       export JAVA_HOME=/android/jdk1.5.0_22
      
     
     
      (
     
     
      如果是
     
     
      Cygwin
     
     
      就設定到
     
     
      JDK
     
     
      安裝的路徑
     
     
      ,
     
     
      例如
     
     
     
     
      export JAVA_HOME=/cygdrive/c/"Program Files"/Java/jdk1.6.0_23)
     
    
    
     
      
       export PATH=${PATH}:${ANT_HOME}/bin
      
     
     
      
     
     
      與
     
     
      
      
       
        NDK=/android-ndk-r5b-windows
       
      
     
    
    
     
      接下來
     
     
      ,
     
     
      執行
     
     
     
     
      ./build.sh
     
    
    
     
      就可以產生
     
     
      ANT
     
     
      執行的環境
     
     
      ,
     
     
      以
     
     
      NDK
     
     
      為例
     
     
      ,
     
     
      可以進到範例目錄
     
    
    
     
      透過
     
     
     
     
      Android SDK tools
     
     
      下的
     
     
     
     
      android.bat
     
     
      產生讓
     
     
      ANT
     
     
      參考的
     
     
      build.xml
     
    
    
     
      snna@snna-PC /android-ndk-r5b-windows/samples/hello-jni
     
    
    
     
      $
      
       
        
         android.bat update project -p . -s
        
       
      
     
    
    
     
      Updated local.properties
     
    
    
     
      Added file C:/cygwin/android-ndk-r5b-windows/samples/hello-jni/build.xml
     
    
    
     
      Added file C:/cygwin/android-ndk-r5b-windows/samples/hello-jni/proguard.cfg
     
    
    
     
      Updated local.properties
     
    
    
     
      Added file C:/cygwin/android-ndk-r5b-windows/samples/hello-jni/tests/build.xml
     
    
    
     
      Added file C:/cygwin/android-ndk-r5b-windows/samples/hello-jni/tests/proguard.cfg
     
    
    
     
      透過
     
     
     
     
      ndk-build
     
     
      進行編譯
     
    
    
     
      snna@snna-PC /android-ndk-r5b-windows/samples/hello-jni
     
    
    
     
      $
      
       
        $NDK/ndk-build
       
      
     
    
    
     
      
       (
      
     
     
      
       要編譯
      
      
      
      
       Debug
      
     
     
      
       版本就是加上
      
      
      
      
       NDK_LOG=1 NDK_DEBUG=1)
      
     
    
    
     
      Gdbserver
      
      
      : [arm-linux-androideabi-4.4.3] libs/armeabi/gdbserver
     
    
    
     
      Gdbsetup
      
      
      : libs/armeabi/gdb.setup
     
    
    
     
      Install
      
      
      : libhello-jni.so =>; libs/armeabi/libhello-jni.so
     
    
    
     
      透過
     
     
      ANT
     
     
      產生
     
     
     
     
      APK
     
    
    
     
      snna@snna-PC /android-ndk-r5b-windows/samples/hello-jni
     
    
    
     
      $
      
       
        ant debug
       
      
     
    
    
     
      Buildfile: C:/cygwin/android-ndk-r5b-windows/samples/hello-jni/build.xml
     
    
    
     
      
      
      [setup] Android SDK Tools Revision 8
     
    
    
     
      
      
      [setup] Project Target: Android 2.2
     
    
    
     
      ….......................
     
    
    
     
      debug:
     
    
    
     
      
      
      [echo] Running zip align on final apk...
     
    
    
     
      
      
      [echo] Debug Package: C:/cygwin/android-ndk-r5b-windows/samples/hello-jni/bin/HelloJni-debug.apk
     
    
    
     
     
    
    
     
      BUILD SUCCESSFUL
     
    
    
     
      Total time: 5 seconds
     
    
    
     
      安裝
     
     
     
     
      APK
     
     
      到
     
     
      android
     
     
      手機環境
     
    
    
     
     
    
    
     
      snna@snna-PC /android-ndk-r5b-windows/samples/hello-jni
     
    
    
     
      $
      
       
        adb install bin/HelloJni-debug.apk (
       
      
     
     
      
       如果之前有安裝過
      
      
       ,
      
     
     
      
       可以加上
      
      
      
      
       -r,
      
     
     
      
       重新安裝
      
      
       )
      
     
    
    
     
      396 KB/s (79155 bytes in 0.195s)
     
    
    
     
      
      
      pkg: /data/local/tmp/HelloJni-debug.apk
     
    
    
     
      Success
     
    
    
     
     
    
    
     
      安裝完畢後
     
     
      ,
     
     
      如果希望透過
     
     
      ndk-gdb
     
     
      除錯時
     
     
      ,
     
     
      可以在程式啟動後
     
     
      ,
     
     
      立刻停住等待除錯器啟動
     
     
      ,
     
     
      不要就直接執行下去
     
     
      ,
     
     
      可以修改
     
     
      Java
     
     
      程式碼加入函式呼叫
     
     
     
     
      android.os.Debug.waitForDebugger() ,
     
     
      如下所示
     
     
      ,
     
     
      修改
     
     
     
     
      /android-ndk-r5b-windows/samples/hello-jni/src/com/example/hellojni/HelloJni.java
     
    
    
     
     
    
    
     
      package com.example.hellojni;
     
    
    
     
     
    
    
     
      import android.app.Activity;
     
    
    
     
      import android.widget.TextView;
     
    
    
     
      import android.os.Bundle;
     
    
    
     
     
    
    
     
     
    
    
     
      public class HelloJni extends Activity
     
    
    
     
      {
     
    
    
     
      
      
      /** Called when the activity is first created. */
     
    
    
     
      
      
      @Override
     
    
    
     
      
      
      public void onCreate(Bundle savedInstanceState)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      android.os.Debug.waitForDebugger();
     
    
    
     
      
      
      super.onCreate(savedInstanceState);
     
    
    
     
     
    
    
     
     
    
    
     
      snna@snna-PC /android-ndk-r5b-windows/samples/hello-jni
     
    
    
     
      $
      
       
        $NDK/ndk-gdb --start
       
      
     
    
    
     
      GNU gdb 6.6
     
    
    
     
      Copyright (C) 2006 Free Software Foundation, Inc.
     
    
    
     
      GDB is free software, covered by the GNU General Public License, and you are
     
    
    
     
      welcome to change it and/or distribute copies of it under certain conditions.
     
    
    
     
      Type "show copying" to see the conditions.
     
    
    
     
      There is absolutely no warranty for GDB.
      
      
      Type "show warranty" for details.
     
    
    
     
      This GDB was configured as "--host=i586-mingw32msvc --target=arm-elf-linux".
     
    
    
     
      (no debugging symbols found)
     
    
    
     
     
    
    
     
     
    
    
     
      
       Android Runtime
      
     
    
    
     
     
    
    
     
      
      
     
     
      包括工具
     
     
     
     
      dexopt,
     
     
      或是
     
     
      app_process(zygote)
     
     
      與
     
     
      dalvikvm
     
     
      這些在
     
     
      Android
     
     
      目錄下可以使用的執行檔
     
     
      ,
     
     
      其實最主要的實作都是基於
     
     
     
     
      /system/lib/libdvm.so,
     
     
      並且透過
     
     
      JNI
     
     
      串起原生程式碼與
     
     
      Java
     
     
      程式碼的介面
     
     
      ,
     
     
      這些工具主要是把要傳遞給
     
     
     
     
      libdvm.so
     
     
      處理的資料
     
     
      ,
     
     
      進行前段的處理
     
     
      ,
     
     
      如下以
     
     
      app_process
     
     
      為例說明
     
     
      Zygote
     
     
      程序的初始化流程
     
     
      .
     
    
    
     
     
    
    
     
      
      
      Dalvik
     
     
      第一個
     
     
      Java
     
     
      應用程式
     
     
     
     
      Zygote,
     
     
      就由此而來
     
     
      , app_process Source Code
     
     
      所在路徑為
     
     
      frameworks/base/cmds/app_process.
     
     
      系統在初始化
     
     
      Zygote
     
     
      時
     
     
      ,
     
     
      會帶入如下的參數
     
    
    
     
      /system/bin/app_process -Xzygote /system/bin --zygote –start-system-server
     
    
    
     
     
    
    
     
      
      
     
     
      由於最終實作的內容是在
     
     
      Java Framework
     
     
      中的
     
     
      ,com.android.internal.os.ZygoteInit (
     
     
      原始碼路徑
     
     
      :frameworks/base/core/java/com/android/internal/os/ZygoteInit.java),
     
     
      在
     
     
      app_process
     
     
      的
     
     
      C
     
     
      實作中
     
     
      ,
     
     
      主要是初始化
     
     
      Dalvik
     
     
      虛擬器
     
     
      ,
     
     
      並且把要帶入
     
     
      Java
     
     
      的資訊加以處理
     
     
      ,
     
     
      我們簡要說明如下
     
     
      .
     
    
    
     
     
    
    
     
      
      
      1,
     
     
      在
     
     
      C
     
     
      程式碼中產生
     
     
     
     
      AndroidRuntime
      
      
      (AndroidRuntime
     
     
      實作在
     
     
      frameworks/base/core/jni/AndroidRuntime.cpp)
     
    
    
     
      
      
      2,
     
     
      呼叫
     
     
      AndroidRuntime::addVmArguments
     
     
      把
     
     
      C
     
     
      參數的個數與內容扣掉屬於
     
     
      app_process
     
     
      的部份
     
     
      (
     
     
      個數減一與字串往前移動一
     
     
      ).
     
     
      傳給
     
     
      AndroidRuntime
     
    
    
     
      
      
      3,
     
     
      如果參數等於
     
     
     
     
      --zygote
     
     
      與隨後參數等於
     
     
     
     
      --start-system-server
     
     
      就把變數
     
     
      startSystemServer
     
     
      設為
     
     
      true,
     
     
      並呼叫
     
     
      set_process_name
     
     
      設定行程名稱為
     
     
     
     
      zygote,
     
     
      再來執行
     
     
      AndroidRuntime::start(const char* className, const bool startSystemServer)
     
     
      函式
     
     
      ,
     
     
      該函式會初始化
     
     
      Dalvik
     
     
      虛擬器
     
     
      (
     
     
      由
     
     
      AndroidRuntime::startVm
     
     
      呼叫函式
     
     
      JNI_CreateJavaVM(
     
     
      原始碼在
     
     
      :dalvik/vm/Jni.c)),
     
     
      並由
     
     
      C
     
     
      透過
     
     
      JNI
     
     
      介面
     
     
      (FindClass,GetStaticMethodID and CallStaticVoidMethod)
     
     
      執行
     
     
      Java
     
     
      的
     
     
     
     
      com.android.internal.os.ZygoteInit Class(
     
     
      原始碼路徑
     
     
      :frameworks/base/core/java/com/android/internal/os/ZygoteInit.java)
     
     
      的
     
     
     
     
      ZygoteInit::main
     
     
      函式
     
     
      ,
     
     
      執行如下行為
     
     
     
     
      (
     
     
      只列舉筆者覺得重要的
     
     
      )
     
    
    
     
      
      
      3.a,
     
     
      註冊
     
     
      ZygoteSocket
     
    
    
     
      
      
      3.b,Preload
     
     
      所需的
     
     
      DEX/Class
     
     
      檔案
     
     
      ,
     
     
      例如
     
     
      :
     
     
      會透過
     
     
      dvmJarFileOpen(
     
     
      原始碼在
     
     
      :dalvik/vm/JarFile.c),
     
     
      解開
     
     
      ZIP
     
     
      壓縮的
     
     
      JAR
     
     
      檔案
     
     
      ,
     
     
      先確認是否有
     
     
      odex
     
     
      結尾的檔案
     
     
      (
     
     
      表示已經做過最佳化的動作
     
     
      ),
     
     
      如果有
     
     
      ,
     
     
      就會確認該
     
     
      odex
     
     
      檔案的
     
     
      Class
     
     
      相依性
     
     
      (
     
     
      如果有相依的
     
     
      Class
     
     
      被更新
     
     
      ,
     
     
      就要重新進行最佳化
     
     
      ),
     
     
      接下來搜尋是否有
     
     
      classes.dex
     
     
      結尾的檔案（尚未被最佳化過
     
     
      ),
     
     
      並呼叫
     
     
      dvmOptimizeDexFile(
     
     
      原始碼在
     
     
      :dalvik/vm/analysis/DexOptimize.c)
     
     
      進行驗證與最佳化
     
     
      DEX
     
     
      的流程
     
     
      .
     
    
    
     
      
      
      3.c,
     
     
      進行初始化後的記憶體回收動作
     
     
     
     
      (GC,Memory Garbage Collection)
     
    
    
     
      
      
      3.d,
     
     
      如果
     
     
      startSystemServer
     
     
      為
     
     
      true,
     
     
      呼叫
     
     
      startSystemServer
     
     
      產生
     
     
      System Server
     
     
      行程
     
     
      .
     
    
    
     
      
      
      3.e,Zygote
     
     
      進入一個
     
     
      Socket
     
     
      等待
     
     
      Client
     
     
      連結的無窮迴圈
     
     
      .
     
     
      至此即完成
     
     
      zygote
     
     
      行程的初始化動作
     
     
      .
     
    
    
     
      
      
      4,
     
     
      如果參數不為
     
     
     
     
      --zygote,
     
     
      就會把
     
     
      Class
     
     
      名稱與
     
     
      C
     
     
      參數的個數與內容扣掉屬於
     
     
      app_process
     
     
      的部份
     
     
      (
     
     
      個數減一與字串往前移動一
     
     
      ).
     
     
      傳給
     
     
      AndroidRuntime.
     
     
      並呼叫
     
     
      set_process_name
     
     
      設定行程為該
     
     
      Class
     
     
      名稱
     
     
      ,
     
     
      再來執行
     
     
      AndroidRuntime::start(const char* className, const bool startSystemServer)
     
     
      函式
     
     
      ,
     
     
      該函式會初始化
     
     
      Dalvik
     
     
      虛擬器
     
     
      ,
     
     
      並由
     
     
      C
     
     
      透過
     
     
      JNI
     
     
      介面執行
     
     
      Java
     
     
      的
     
     
     
     
      com.android.internal.os.RuntimeInit Class(
     
     
      原始碼路徑
     
     
      :frameworks/base/core/java/com/android/internal/os/RuntimeInit.java)
     
     
      的
     
     
     
     
      RuntimeInit::main
     
     
      函式
     
    
    
     
     
    
    
     
     
    
    
     
      
       JNI (Java Native Interface)
      
     
    
    
     
     
    
    
     
      
      
      JNI
     
     
      的介面是原本
     
     
      Java
     
     
      環境中就有的機制
     
     
      ,
     
     
      讓
     
     
      Java
     
     
      的應用程式可以跟其他語言實作的動態函式庫進行互通
     
     
      ,
     
     
      更進一步來說
     
     
      ,
     
     
      就是可以透過
     
     
      Native Code
     
     
      執行的高效率
     
     
      ,
     
     
      優化
     
     
      Java
     
     
      應用程式執行上表現
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      有兩份關於
     
     
      JNI
     
     
      的文件
     
     
      ,
     
     
      是
     
     
      Google
     
     
      推薦開發者可以參考的
     
    
    
     
      
      
      1,Introduction and Tutorial
      
      
      
      (http://java.sun.com/docs/books/jni/html/jniTOC.html)
     
    
    
     
      
      
      2, Java Native Interface Specification for J2SE 1.6
      
      
      
      (http://download.oracle.com/javase/6/docs/technotes/guides/jni/spec/jniTOC.html)
     
    
    
     
      
      
     
    
    
     
      
      
      JNI
     
     
      的
     
     
      C
     
     
      函式可以存取
     
     
     
     
      "JavaVM"
     
     
      或
     
     
      "JNIEnv"
     
     
     
     
      的資料結構
     
     
      ,
     
     
      一個
     
     
      JNI C
     
     
      函式的第一個函式參數會是
     
     
      JNIEnv (
     
     
      例如
     
     
      :HelloWorld(JNIEnv * env, jobject jobj)),
     
     
      並且以
     
     
      Dalvik
     
     
      的設計而言
     
     
      ,
     
     
      是以一個
     
     
      Java AP
     
     
      對應到一個
     
     
      Linux Process
     
     
      並對應到一個
     
     
      Dalvik VM
     
     
      的實體
     
     
      ,
     
     
      也就是說
     
     
      ,Dalvik VM
     
     
      本身並不會進行
     
     
      MultiTask Java AP
     
     
      的動作
     
     
      ,
     
     
      同時
     
     
      ,
     
     
      每個
     
     
      Java AP
     
     
      與其對應的
     
     
      JNI C
     
     
      動態函式庫
     
     
      ,
     
     
      就會以一個
     
     
      Linux
      
      
      Process
     
     
      行程空間
     
     
      (
     
     
      每個都是一個獨立的
     
     
      4GB
     
     
      記憶體空間
     
     
      )
     
     
      為單位來運作
     
     
      .
     
    
    
     
     
    
    
     
      
      
      JNI
     
     
      可以透過
     
     
      FindClass
     
     
      取得
     
     
      Java
     
     
      世界所宣告的
     
     
      Class,
     
     
      透過
     
     
      GetFieldID
     
     
      取得
     
     
      Java
     
     
      世界的變數
     
     
      (
     
     
      並且也可以改變
     
     
      ,
     
     
      設定值與使用該變數
     
     
      ),
     
     
      與可以透過
     
     
      GetMethodID
     
     
      取得
     
     
      Java
     
     
      世界的
     
     
      Class
     
     
      函式呼叫
     
     
      .
     
     
      有關字元部分需要注意的是
     
     
      ,Java
     
     
      世界採用的字元是以
     
     
      Unicode(UTF-16 LE)
     
     
      編碼
     
     
      ,
     
     
      而在
     
     
      JNI
     
     
      的
     
     
      C
     
     
      世界中是採用
     
     
      UTF-8
     
     
      的方式編碼
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      以
     
     
      c
     
     
      為例
     
     
      ,
     
     
      在實作
     
     
      JNI
     
     
      的函式時
     
     
      ,
     
     
      所面對的資料型態
     
     
      ,
     
     
      主要是以
     
     
      j
     
     
      開頭加上對應的
     
     
      Java
     
     
      端的資料型態
     
     
      ,
     
     
      例如
     
    
    
     
     
    
    
     
      
       
        
         
          Java
         
         
          中的型態
         
        
       
       
        
         
          JNI
         
         
          中的型態
         
        
       
       
        
         
          對應到
         
         
          C
         
         
          實作中的型態
         
        
       
      
      
       
        
         
          boolean
         
        
       
       
        
         
          jboolean
         
        
       
       
        
         
          unsigned char
          
          
          ( unsigned 8 bits)
         
        
       
      
      
       
        
         
          byte
         
        
       
       
        
         
          jbyte
         
        
       
       
        
         
          signed char (signed 8 bits)
         
        
       
      
      
       
        
         
          char
         
        
       
       
        
         
          jchar
         
        
       
       
        
         
          unsigned short
          
          
          (unsigned 16 bits)
         
        
       
      
      
       
        
         
          short
         
        
       
       
        
         
          jshort
         
        
       
       
        
         
          short (signed 16 bits)
         
        
       
      
      
       
        
         
          int
         
        
       
       
        
         
          jint
         
        
       
       
        
         
          int (signed 32 bits)
         
        
       
      
      
       
        
         
          long
         
        
       
       
        
         
          jlong
         
        
       
       
        
         
          long long
         
         
          (
         
         
          signed 64 bits
         
         
          )
         
        
       
      
      
       
        
         
          float
         
        
       
       
        
         
          jfloat
         
        
       
       
        
         
          float (32-bit IEEE 754)
         
        
       
      
      
       
        
         
          double
         
        
       
       
        
         
          jdouble
         
        
       
       
        
         
          double
         
         
          (
         
         
          64-bit IEEE 754)
         
        
       
      
      
       
        
         
          size
         
        
       
       
        
         
          jsize
         
        
       
       
        
         
          int (signed 32 bits)
         
        
       
      
      
       
        
         
          void
         
        
       
       
        
         
          void
         
        
       
       
        
         
          void
         
        
       
      
      
       
        
         
          String
         
        
       
       
        
         
          jstring
         
        
       
       
        
         
          void *
         
        
       
      
      
       
        
         
          object
         
        
       
       
        
         
          jobject
         
        
       
       
        
         
          void *
         
        
       
      
      
       
        
         
          class
         
        
       
       
        
         
          jclass
         
        
       
       
        
         
          void *
         
        
       
      
      
       
        
         
          array
         
        
       
       
        
         
          jarray
         
        
       
       
        
         
          void *
         
        
       
      
      
       
        
         
         
        
       
       
        
         
          jobjectArray/jbooleanArray/jbyteArray/jcharArray/jshortArray/jintArray/jlongArray/jfloatArray/jdoubleArray/jthrowable/jweak
         
        
       
       
        
         
          void *
         
        
       
      
     
    
    
     
     
    
    
     
      
      
     
     
      需要注意的是
     
     
      ,
     
     
      在
     
     
      Java
     
     
      中字元是以
     
     
      Unicode
     
     
      的方式編碼
     
     
      ,
     
     
      所以
     
     
      jchar
     
     
      對應一個
     
     
      Java
     
     
      字元
     
     
      ,
     
     
      才會等於一個
     
     
      unsigned short 16bits
     
     
      字元
     
     
      ,
     
     
      但是在
     
     
      JNI
     
     
      這邊
     
     
      C
     
     
      語言的實作則是以
     
     
      UTF-8
     
     
      的方式來實現
     
     
      ,
     
     
      也就是說
     
     
      ASCII
     
     
      字元固定為
     
     
      1
     
     
      個
     
     
      bytes,
     
     
      但中文或其他語系的編碼就會有
     
     
      2-6bytes
     
     
      不等的編碼長度
     
     
      (
     
     
      可以參考
     
     
      
       http://en.wikipedia.org/wiki/UTF-8
      
      ),
     
     
      中文等亞洲語系通常為
     
     
      3bytes
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      如下
     
     
      ,
     
     
      提供一個簡單沒有傳入參數與傳回值的
     
     
      JNI
     
     
      範例
     
     
     
     
      libtest8.c
     
    
    
     
      #include <jni.h>;
     
    
    
     
      #include <stdio.h>;
     
    
    
     
      #include <string.h>;
     
    
    
     
      #include <stdlib.h>;
     
    
    
     
      #define LOG_TAG "C LOG DEMO"
     
    
    
     
      #undef LOG
     
    
    
     
      #include <utils/Log.h>;
     
    
    
     
      
      
      
      
     
    
    
     
      JNIEXPORT void JNICALL Java_loda_Test8_Test8_HelloWorld(JNIEnv * env, jobject jobj)
     
    
    
     
      {
     
    
    
     
      
      
      printf("Hello World in Console./n");
     
    
    
     
      
      
      LOGV("Hello World! This color is for Verbose.");
     
    
    
     
      
      
      LOGD("Hello World! This color is for Debug.");
     
    
    
     
      
      
      LOGI("Hello World! This color is for Information");
     
    
    
     
      
      
      LOGW("Hello World! This color is for Warnning.");
     
    
    
     
      
      
      LOGE("Hello World! This color is for Error.");
     
    
    
     
      }
     
    
    
     
     
    
    
     
      透過如下內容的
     
     
      Android.mk
     
    
    
     
      LOCAL_PATH := $(my-dir)
     
    
    
     
      include $(CLEAR_VARS)
     
    
    
     
      LOCAL_SRC_FILES := libtest8.c
     
    
    
     
      LOCAL_SHARED_LIBRARIES := liblog
     
    
    
     
      LOCAL_MODULE := libtest8
     
    
    
     
      LOCAL_PRELINK_MODULE := false
     
    
    
     
      include $(BUILD_SHARED_LIBRARY)
     
    
    
     
      
      
     
    
    
     
      之後執行
     
    
    
     
      [root@localhost froyo]# make libtest8
     
    
    
     
      ============================================
     
    
    
     
      PLATFORM_VERSION_CODENAME=REL
     
    
    
     
      PLATFORM_VERSION=2.2.1
     
    
    
     
      TARGET_PRODUCT=generic
     
    
    
     
      TARGET_BUILD_VARIANT=eng
     
    
    
     
      TARGET_SIMULATOR=
     
    
    
     
      TARGET_BUILD_TYPE=release
     
    
    
     
      TARGET_BUILD_APPS=
     
    
    
     
      TARGET_ARCH=arm
     
    
    
     
      HOST_ARCH=x86
     
    
    
     
      HOST_OS=linux
     
    
    
     
      HOST_BUILD_TYPE=release
     
    
    
     
      BUILD_ID=MASTER
     
    
    
     
      ============================================
     
    
    
     
      target thumb C: libtest8 <= system/core/libtest8/libtest8.c
     
    
    
     
      target SharedLib: libtest8 (out/target/product/generic/obj/SHARED_LIBRARIES/libt
     
    
    
     
      est8_intermediates/LINKED/libtest8.so)
     
    
    
     
      target Non-prelinked: libtest8 (out/target/product/generic/symbols/system/lib/li
     
    
    
     
      btest8.so)
     
    
    
     
      target Strip: libtest8 (out/target/product/generic/obj/lib/libtest8.so)
     
    
    
     
      Install: out/target/product/generic/system/lib/libtest8.so
     
    
    
     
     
    
    
     
     
    
    
     
      之後
     
     
      ,
     
     
      筆者把
     
     
      libtest.so
     
     
      放到
     
     
      Windows
     
     
      環境下
     
     
      ,
     
     
      首先原本的
     
     
      system.img
     
     
      载入是唯讀的
     
     
      ,
     
     
      必須要透過
     
    
    
     
      adb reomunt
     
    
    
     
      讓
     
     
      system.img
     
     
      可以寫入資料
     
     
     
     
      (/dev/block/mtdblock0 /system yaffs2 rw 0 0)
     
    
    
     
      之後
     
     
      ,
     
     
      透過
     
     
     
     
      adb push libtest8.so /system/lib
     
    
    
     
      616 KB/s (25248 bytes in 0.040s)
     
    
    
     
      把函式庫放到目標主機上
     
     
      ,
     
     
      然後透過
     
     
      Eclipse
     
     
      執行下面的程式碼
     
    
    
     
      package loda.Test8;
     
    
    
     
      
      import android.app.Activity;
      
      import android.util.Log;
      
      import android.os.Bundle;
      
      import java.io.IOException;
      
      import java.io.InputStream;
      
      import java.lang.IllegalStateException;
      
      
      public class Test8 extends Activity {
      
      
      
      private native void HelloWorld();
      
      
      
      
      
      
      
      static {
      
      
      
      
      
      System.loadLibrary("test8");
      
      
      
      
      
      }
      
      
      
      
      
      
      @Override
      
      
      
      public void onCreate(Bundle savedInstanceState) {
      
      
      
      super.onCreate(savedInstanceState);
      
      
      
      
      
      Log.i("loda", "libtest8 Before Call JNI HelloWorld");
      
      
      
      HelloWorld();
      
      
      
      
      
      Log.i("loda", "libtest8 After Call JNI HelloWorld");
      
      
      
      
      
      setContentView(R.layout.main);
      
      
      
      }
      
      
      
      
      }
     
    
    
     
     
    
    
     
      就可以看到在
     
     
      Eclipse
     
     
      的環境中
     
     
      ,
     
     
      的
     
     
      logcat
     
     
      有來自
     
     
      Java
     
     
      程式透過
     
     
      JNI
     
     
      介面呼叫
     
     
      HelloWorld C
     
     
      函式庫的結果了
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      接下來
     
     
      ,
     
     
      我們把這個
     
     
      JNI
     
     
      範例加上傳入參數與傳回值
     
     
      ,
     
     
      如下範例
     
     
      C
     
     
      程式
     
    
    
     
     
    
    
     
      #include <jni.h>;
     
    
    
     
      #include <stdio.h>;
     
    
    
     
      #include <string.h>;
     
    
    
     
      #include <stdlib.h>;
     
    
    
     
      #define LOG_TAG "C LOG DEMO"
     
    
    
     
      #undef LOG
     
    
    
     
      #include <utils/Log.h>;
     
    
    
     
      
      
     
    
    
     
      char gTest8Buffer[]="Unicode based Global Sring Reference from JNI-C";
     
    
    
     
      
      
      
      
     
    
    
     
      JNIEXPORT jstring JNICALL Java_loda_Test8d_Test8d_HelloWorld(JNIEnv * env, jobject jobj,jint test_int,jstring test_string,jdouble test_double)
     
    
    
     
      {
     
    
    
     
      
      
      const jbyte *jni_string;
     
    
    
     
      
      
      jni_string=(*env)->;GetStringUTFChars(env,test_string,0);
     
    
    
     
      
      
      if(jni_string==NULL)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      return NULL;
     
    
    
     
      
      
      }
     
    
    
     
      
      
      printf("int:%d string:%s double:%f/n",test_int,jni_string,test_double);
     
    
    
     
      
      
      LOGI("int:%d string:%s double:%f/n",test_int,jni_string,test_double);
     
    
    
     
      
      
      (*env)->;ReleaseStringUTFChars(env,test_string,jni_string);
     
    
    
     
      
      
      return (*env)->;NewStringUTF(env, gTest8Buffer);
     
    
    
     
      }
     
    
    
     
     
    
    
     
      我們額外加入
     
     
      , int,String
     
     
      與
     
     
      double
     
     
      型態的參數
     
     
      ,
     
     
      由
     
     
      Java
     
     
      端傳入給
     
     
      JNI
     
     
      的
     
     
      C
     
     
      程式
     
     
      ,
     
     
      編譯後
     
     
      ,
     
     
      同樣的透過
     
     
      adb push libtest8d.so /system/lib
     
    
    
     
      61 KB/s (5164 bytes in 0.082s)
     
    
    
     
      傳到
     
     
      Android Target
     
     
      上
     
     
      ,
     
     
      然後再
     
     
      Eclipse
     
     
      上編譯如下的
     
     
      Java
     
     
      程式
     
    
    
     
     
    
    
     
      package loda.Test8d;
      
      
      import android.app.Activity;
      
      import android.util.Log;
      
      import android.os.Bundle;
      
      
      public class Test8d extends Activity {
      
      
      
      
      
      
      private native String HelloWorld(int a,String b,double c);
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      static {
      
      
      
      
      
      
      
      System.loadLibrary("test8d");
      
      
      
      
      
      }
      
      
      
      
      
      
      
      
      @Override
      
      
      
      public void onCreate(Bundle savedInstanceState) {
      
      
      
      super.onCreate(savedInstanceState);
      
      
      
      Log.i("loda", "libtest8d Before Call JNI HelloWorld");
      
      
      
      String vStr="It is a string from Java";
      
      
      
      String vRet= HelloWorld(5799232,vStr,123.456);
      
      
      
      
      
      Log.i("loda", vRet);
      
      
      
      
      
      Log.i("loda", "libtest8d After Call JNI HelloWorld");
      
      
      
      
      
      setContentView(R.layout.main);
      
      
      
      }
      
      }
     
    
    
     
     
    
    
     
      
      
     
     
      就可以示範如何從
     
     
      Java
     
     
      端傳遞整數
     
     
      ,
     
     
      字串與浮點數給
     
     
      JNI C
     
     
      程式
     
     
      ,
     
     
      然後再從
     
     
      C
     
     
      程式中傳遞結果字串給
     
     
      Java
     
     
      應用程式
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      接下來
     
     
      ,
     
     
      我們再舉另一個例子
     
     
      ,
     
     
      示範如何從
     
     
      JNI C
     
     
      程式中
     
     
      ,
     
     
      去呼叫
     
     
      Java
     
     
      端的應用函式
     
     
      ,
     
     
      如此我們就可以達成
     
     
      C
     
     
      與
     
     
      Java
     
     
      端彼此可以呼叫的結果
     
     
      ,
     
     
      並且可以驗證這些
     
     
      JNI
     
     
      的行為在
     
     
      Android
     
     
      架構下確實可以運作無誤
     
     
      .
     
    
    
     
      (
     
     
      參考
     
     
      :
      
       http://journals.ecs.soton.ac.uk/java/tutorial/native1.1/implementing/method.html
      
      )
     
    
    
     
     
    
    
     
     
    
    
     
      
       
        
         
          Signature
         
        
       
       
        
         
          Java Type
         
        
       
      
      
       
        
         
          Z
         
        
       
       
        
         
          boolean
         
        
       
      
      
       
        
         
          B
         
        
       
       
        
         
          byte
         
        
       
      
      
       
        
         
          C
         
        
       
       
        
         
          char
         
        
       
      
      
       
        
         
          S
         
        
       
       
        
         
          short
         
        
       
      
      
       
        
         
          I
         
        
       
       
        
         
          int
         
        
       
      
      
       
        
         
          J
         
        
       
       
        
         
          long
         
        
       
      
      
       
        
         
          F
         
        
       
       
        
         
          float
         
        
       
      
      
       
        
         
          D
         
        
       
       
        
         
          double
         
        
       
      
      
       
        
         
          L
         
        
       
       
        
         
          fully-qualified-class;
         
        
       
      
      
       
        
         
          [ type
         
        
       
       
        
         
          type[]
         
        
       
      
      
       
        
         
          ( arg-types ) ret-type
         
        
       
       
        
         
          method type
         
        
       
      
     
    
    
     
      
      
     
    
    
     
     
    
    
     
      如下所示
     
     
      ,
     
     
      我們在
     
     
      JNI C
     
     
      函式中透過
     
     
     
     
      GetMethodID
     
     
      取得
     
     
      Java
     
     
      函式
     
     
      String CallFromJNI(int a,String b,double c)
     
     
      的
     
     
      c
     
     
      函式與參數宣告
     
     
      “(ILjava/lang/String;D)Ljava/lang/String;”,
     
    
    
     
     
    
    
     
      #include <jni.h>;
     
    
    
     
      #include <stdio.h>;
     
    
    
     
      #include <string.h>;
     
    
    
     
      #include <stdlib.h>;
     
    
    
     
      #define LOG_TAG "C LOG DEMO"
     
    
    
     
      #undef LOG
     
    
    
     
      #include <utils/Log.h>;
     
    
    
     
      
      
     
    
    
     
      char gTest8Buffer[]="Unicode based Global Sring Reference from JNI-C";
     
    
    
     
      
      
     
    
    
     
      JNIEXPORT jstring JNICALL Java_loda_Test8d_Test8d_HelloWorld(JNIEnv * env, jobject jobj,jint test_int,jstring test_string,jdouble test_double)
     
    
    
     
      {
     
    
    
     
      
      
      jclass vClass=(*env)->;GetObjectClass(env,jobj);
     
    
    
     
      
      
      jmethodID vMethodID=(*env)->;GetMethodID(env,vClass,"CallFromJNI","(ILjava/lang/String;D)Ljava/lang/String;");
     
    
    
     
      
      
      if(vMethodID==NULL)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      LOGI("Falied to load Java Func CallFromJNI");
     
    
    
     
      
      
      return NULL;
     
    
    
     
      
      
      }
     
    
    
     
      
      
      jstring vStr=(*env)->;NewStringUTF(env, gTest8Buffer);
     
    
    
     
      
      
      
      
      jstring vRetStr=(*env)->;CallObjectMethod(env,jobj,vMethodID,123,vStr,4321.1234);
     
    
    
     
      
      
      const jbyte *jni_string=(*env)->;GetStringUTFChars(env,vRetStr,0);
     
    
    
     
      
      
      if(jni_string==NULL)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      return NULL;
     
    
    
     
      
      
      }
     
    
    
     
      
      
      LOGI("Java Method Return String:%s",jni_string);
     
    
    
     
      
      
      (*env)->;ReleaseStringUTFChars(env,vRetStr,jni_string);
     
    
    
     
      
      
      return vStr;
     
    
    
     
     
    
    
     
      透過如下命令傳到手機上
     
    
    
     
      adb push libtest8d.so /system/lib
     
    
    
     
      419 KB/s (5160 bytes in 0.012s)
     
    
    
     
     
    
    
     
      再透過如下的
     
     
      Java
     
     
      程式碼
     
     
      ,
     
     
      就可以完成從
     
     
      Java
     
     
      呼叫
     
     
      JNI C
     
     
      函式
     
     
      ,
     
     
      到由
     
     
      JNI C
     
     
      函式呼叫回
     
     
      Java
     
     
      函式的兩者互通的函式呼叫機制
     
     
      ,
     
     
      並可在
     
     
      Android
     
     
      環境中驗證無誤
     
     
      ,
     
     
      如下範例程式碼
     
    
    
     
     
    
    
     
      package loda.Test8d;
      
      
      import android.app.Activity;
      
      import android.util.Log;
      
      import android.os.Bundle;
      
      
      public class Test8d extends Activity {
      
      
      
      
      
      
      private native String HelloWorld(int a,String b,double c);
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      static {
      
      
      
      
      
      
      
      System.loadLibrary("test8d");
      
      
      
      
      
      }
      
      
      
      
      
      private String CallFromJNI(int a,String b,double c)
      
      
      
      
      
      {
      
      
      
      
      
      Log.i("loda", "int:"+a+"_String:"+b+"_double:"+c);
      
      
      
      
      
      
      
      return "From CallFromJNI in Java";
      
      
      
      
      
      }
      
      
      
      @Override
      
      
      
      public void onCreate(Bundle savedInstanceState) {
      
      
      
      super.onCreate(savedInstanceState);
      
      
      
      Log.i("loda", "libtest8d Before Call JNI HelloWorld");
      
      
      
      String vStr="It is a string from Java";
      
      
      
      String vRet= HelloWorld(5799232,vStr,123.456);
      
      
      
      
      
      Log.i("loda", vRet);
      
      
      
      
      
      Log.i("loda", "libtest8d After Call JNI HelloWorld");
      
      
      
      
      
      setContentView(R.layout.main);
      
      
      
      }
      
      }
     
    
    
     
     
    
    
     
      
      
     
     
      最後
     
     
      ,
     
     
      再示範如何透過
     
     
      JNI C
     
     
      函式
     
     
      ,
     
     
      去取得
     
     
      Java
     
     
      的
     
     
      Class
     
     
      變數的機制
     
     
      ,
     
     
      雖然一般模組化的設計
     
     
      ,
     
     
      跨模塊的變數存取最好都是透過函式實作來達成
     
     
      ,
     
     
      直接去存取變數並不是一個好的實作方式
     
     
      ,
     
     
      但本文的目的主要是演示這些
     
     
      JNI
     
     
      操作的實例作為相關設計的參考之用
     
     
      ,
     
     
      所以
     
     
      ,
     
     
      還請僅供各位參考
     
     
      ,
     
     
      實作上還是建議可以透過函式來使用跨模組的變數
     
     
      ,
     
     
      而不是直接自行存取造成後續維護或是問題收斂上的困難
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      如下為
     
     
      JNI C
     
     
      程式碼的範例
     
     
      ,
     
     
      由
     
     
      C
     
     
      程式碼去參考
     
     
      Java
     
     
      程式碼中宣告的
     
     
      int,String
     
     
      與
     
     
      double
     
     
      變數
     
    
    
     
      #include <jni.h>;
      
      
     
    
    
     
      #include <stdio.h>;
     
    
    
     
      #include <string.h>;
     
    
    
     
      #include <stdlib.h>;
     
    
    
     
      #define LOG_TAG "C LOG DEMO"
     
    
    
     
      #undef LOG
     
    
    
     
      #include <utils/Log.h>;
     
    
    
     
     
    
    
     
      char gTest8Buffer[]="Sring from JNI-C";
     
    
    
     
     
    
    
     
      JNIEXPORT jstring JNICALL Java_loda_Test8e_Test8e_HelloWorld(JNIEnv * env, jobject jobj)
     
    
    
     
      {
     
    
    
     
      
      
      jfieldID vFieldID;
     
    
    
     
      
      
      jint jInt;
     
    
    
     
      
      
      jstring jStr;
     
    
    
     
      
      
      jdouble jDouble;
     
    
    
     
      
      
      const char *vpTemp;
     
    
    
     
      
      
     
    
    
     
      
      
      jclass vClass=(*env)->;GetObjectClass(env,jobj);
     
    
    
     
      
      
      /////////////////////////////////////////////
     
    
    
     
      
      
      //Get and Set Integer from Java
     
    
    
     
      
      
      //
     
    
    
     
      
      
      vFieldID=(*env)->;GetFieldID(env,vClass,"IntInJava","I");
     
    
    
     
      
      
      if(vFieldID==NULL)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      LOGI("Falied to load Java Integer Variable");
     
    
    
     
      
      
      return NULL;
     
    
    
     
      
      
      }
     
    
    
     
      
      
      jInt=(*env)->;GetIntField(env,jobj,vFieldID);
     
    
    
     
      
      
      if(jInt==0)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      LOGI("Falied to get jInt Object");
     
    
    
     
      
      
      return NULL;
     
    
    
     
      
      
      }
     
    
    
     
      
      
      LOGI("jInt:%d",jInt);
     
    
    
     
      
      
      jInt=987654321;
     
    
    
     
      
      
      (*env)->;SetIntField(env,jobj,vFieldID,jInt);
     
    
    
     
      
      
      /////////////////////////////////////////////
     
    
    
     
      
      
      /////////////////////////////////////////////
     
    
    
     
      
      
      //Get and Set String from Java
     
    
    
     
      
      
      //
     
    
    
     
      
      
      vFieldID=(*env)->;GetFieldID(env,vClass,"StringInJava","Ljava/lang/String;");
     
    
    
     
      
      
      if(vFieldID==NULL)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      LOGI("Falied to load Java String Variable");
     
    
    
     
      
      
      return NULL;
     
    
    
     
      
      
      }
     
    
    
     
      
      
      jStr=(*env)->;GetObjectField(env,jobj,vFieldID);
     
    
    
     
      
      
      if(jStr==NULL)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      LOGI("Falied to get jStr Object");
     
    
    
     
      
      
      return NULL;
     
    
    
     
      
      
      }
     
    
    
     
      
      
      vpTemp=(*env)->;GetStringUTFChars(env,jStr,NULL);
     
    
    
     
      
      
      if(vpTemp==NULL)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      LOGI("Falied to get UTF8 String Variable");
     
    
    
     
      
      
      return NULL;
     
    
    
     
      
      
      }
      
      
     
    
    
     
      
      
      LOGI("jStr:%s",vpTemp);
     
    
    
     
      
      
      (*env)->;ReleaseStringUTFChars(env,jStr,vpTemp);
     
    
    
     
      
      
      jStr=(*env)->;NewStringUTF(env,"JNI C Copy to Java String Variable");
     
    
    
     
      
      
      if(jStr==NULL)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      LOGI("Falied to allocate UTF8 String Variable");
      
      
     
    
    
     
      
      
      return NULL;
     
    
    
     
      
      
      }
     
    
    
     
      
      
      (*env)->;SetObjectField(env,jobj,vFieldID,jStr);
     
    
    
     
      
      
      ////////////////////////////////////////////////
     
    
    
     
      
      
      /////////////////////////////////////////////
     
    
    
     
      
      
      //Get and Set Double from Java
     
    
    
     
      
      
      //
     
    
    
     
      
      
      vFieldID=(*env)->;GetFieldID(env,vClass,"DoubleInJava","D");
     
    
    
     
      
      
      if(vFieldID==NULL)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      LOGI("Falied to load Java Double Variable");
     
    
    
     
      
      
      return NULL;
     
    
    
     
      
      
      }
     
    
    
     
      
      
      jDouble=(*env)->;GetDoubleField(env,jobj,vFieldID);
     
    
    
     
      
      
      if(jDouble==0)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      LOGI("Falied to get jDouble Object");
     
    
    
     
      
      
      return NULL;
     
    
    
     
      
      
      }
     
    
    
     
      
      
      LOGI("jDouble:%f",jDouble);
     
    
    
     
      
      
      jDouble=9876.5432;
     
    
    
     
      
      
      (*env)->;SetDoubleField(env,jobj,vFieldID,jDouble);
     
    
    
     
      
      
      /////////////////////////////////////////////
     
    
    
     
      
      
      jstring vStr=(*env)->;NewStringUTF(env, gTest8Buffer);
      
      
     
    
    
     
      
      
      return vStr;
     
    
    
     
      }
     
    
    
     
     
    
    
     
      透過如下命令傳到手機上
     
    
    
     
      adb push libtest8e.so /system/lib
     
    
    
     
      334 KB/s (5136 bytes in 0.015s)
     
    
    
     
     
    
    
     
      如下所示
     
     
      ,
     
     
      為搭配上述
     
     
      JNI C
     
     
      程式碼參考到
     
     
      Java
     
     
      中變數
     
     
      ,
     
     
      所配套的
     
     
      Java
     
     
      程式碼
     
    
    
     
      package loda.Test8e;
      
      
      import android.app.Activity;
      
      import android.util.Log;
      
      import android.os.Bundle;
      
      
      public class Test8e extends Activity {
      
      
      
      
      
      
      private native String HelloWorld();
      
      
      
      
      
      
      
      
      
      private int IntInJava;
      
      
      
      
      
      private String StringInJava;
      
      
      
      
      
      private double DoubleInJava;
      
      
      
      
      
      
      
      
      
      
      static {
      
      
      
      
      
      
      
      System.loadLibrary("test8e");
      
      
      
      
      
      }
      
      
      
      
      
      
      
      
      
      
      @Override
      
      
      
      public void onCreate(Bundle savedInstanceState) {
      
      
      
      super.onCreate(savedInstanceState);
      
      
      
      IntInJava=99999;
      
      
      
      StringInJava="String from Java";
      
      
      
      DoubleInJava=7777.6666;
      
      
      
      Log.i("loda", "libtest8e Before Call JNI HelloWorld");
      
      
      
      String vRet= HelloWorld();
      
      
      
      
      
      Log.i("loda:", "IntInJava:" + IntInJava);
      
      
      
      
      
      Log.i("loda:","StringInJava:" + StringInJava);
      
      
      
      
      
      Log.i("loda:","DoubleInJava:" + DoubleInJava);
      
      
      
      
      
      Log.i("Return String:", vRet);
      
      
      
      
      
      Log.i("loda", "libtest8e After Call JNI HelloWorld");
      
      
      
      
      
      setContentView(R.layout.main);
      
      
      
      }
      
      }
      
      
     
    
    
     
      
      
     
     
      接下來
     
     
      ,
     
     
      讓我們示範由
     
     
      JNI C
     
     
      程式碼中
     
     
      ,
     
     
      透過初始化要使用的
     
     
      Java Class
     
     
      與使用所包含的
     
     
      Method
     
    
    
     
      #include <jni.h>;
      
      
     
    
    
     
      #include <stdio.h>;
     
    
    
     
      #include <string.h>;
     
    
    
     
      #include <stdlib.h>;
     
    
    
     
      #define LOG_TAG "C LOG DEMO"
     
    
    
     
      #undef LOG
     
    
    
     
      #include <utils/Log.h>;
     
    
    
     
     
    
    
     
      char gTest8Buffer[]="Sring from JNI-C";
     
    
    
     
     
    
    
     
      JNIEXPORT jstring JNICALL Java_loda_Test8f_Test8f_HelloWorld(JNIEnv * env, jobject jobj)
     
    
    
     
      {
     
    
    
     
      
      
      jmethodID vMethodID;
     
    
    
     
      
      
      jobject vNewObj;
     
    
    
     
      
      
     
    
    
     
      
      
      jclass vClass=(*env)->;FindClass(env,"loda/Test8f/MyJavaClass");
     
    
    
     
      
      
      if(vClass==NULL)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      LOGI("Falied to FindClass MyJavaClass");
     
    
    
     
      
      
      return NULL;
     
    
    
     
      
      
      }
      
      
     
    
    
     
      
      
      /////
     
    
    
     
      
      
      vMethodID=(*env)->;GetMethodID(env,vClass,"<init>;","()V");
     
    
    
     
      
      
      if(vMethodID==NULL)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      
      
      LOGI("Falied to Get init of MyJavaClass");
     
    
    
     
      
      
      return NULL;
     
    
    
     
      
      
      }
     
    
    
     
      
      
      vNewObj=(*env)->;NewObject(env,vClass, vMethodID, NULL);
     
    
    
     
      
      
      /////
     
    
    
     
      
      
      vMethodID=(*env)->;GetMethodID(env,vClass,"MyRun","(Ljava/lang/String;)Ljava/lang/String;");
     
    
    
     
      
      
      if(vMethodID==NULL)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      LOGI("Falied to Get MyRun of MyJavaClass");
     
    
    
     
      
      
      return NULL;
     
    
    
     
      
      
      }
     
    
    
     
      
      
      LOGI("Get MyJavaClass Method MyRun");
     
    
    
     
      
      
      jstring vStr=(*env)->;NewStringUTF(env, gTest8Buffer);
     
    
    
     
      
      
      jstring vRetStr=(*env)->;CallObjectMethod(env,vNewObj,vMethodID,vStr);
     
    
    
     
      
      
      const jbyte *jni_string=(*env)->;GetStringUTFChars(env,vRetStr,0);
     
    
    
     
      
      
      if(jni_string==NULL)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      
      
      LOGI("Falied to GetStringUTFChars");
     
    
    
     
      
      
      return NULL;
     
    
    
     
      
      
      }
     
    
    
     
      
      
      LOGI("Java Method Return String:%s",jni_string);
     
    
    
     
      
      
      (*env)->;ReleaseStringUTFChars(env,vRetStr,jni_string);
      
      
     
    
    
     
      
      
      (*env)->;DeleteLocalRef(env,vClass);
     
    
    
     
      
      
      return vStr;
     
    
    
     
      }
     
    
    
     
     
    
    
     
      透過如下命令傳到手機上
     
    
    
     
      adb push libtest8f.so /system/lib
     
    
    
     
      417 KB/s (5132 bytes in 0.012s)
     
    
    
     
     
    
    
     
      如下所示
     
     
      ,
     
     
      為搭配上述
     
     
      JNI C
     
     
      程式碼參考到
     
     
      Java
     
     
      中變數
     
     
      ,
     
     
      所配套的
     
     
      Java
     
     
      程式碼
     
    
    
     
      package loda.Test8f;
     
    
    
     
     
    
    
     
      import android.app.Activity;
     
    
    
     
      import android.util.Log;
     
    
    
     
      import android.os.Bundle;
     
    
    
     
     
    
    
     
      public class Test8f extends Activity {
     
    
    
     
     
    
    
     
      
      
      private native String HelloWorld();
      
      
      
      
     
    
    
     
      
      
      static {
     
    
    
     
      
      
      
      
      System.loadLibrary("test8f");
     
    
    
     
      
      
      }
      
      
     
    
    
     
      
      
     
    
    
     
      
      
      @Override
     
    
    
     
      
      
      public void onCreate(Bundle savedInstanceState) {
     
    
    
     
      
      
      super.onCreate(savedInstanceState);
     
    
    
     
      
      
      String vRet= HelloWorld();
      
      
     
    
    
     
      
      
      Log.i("Return String:", vRet);
      
      
     
    
    
     
      
      
      setContentView(R.layout.main);
     
    
    
     
      
      
      }
     
    
    
     
      }
     
    
    
     
     
    
    
     
      class MyJavaClass implements Runnable
     
    
    
     
      {
     
    
    
     
      
      
      public void run()
     
    
    
     
      
      
      {
     
    
    
     
      
      
     
    
    
     
      
      
      }
     
    
    
     
      
      
      public String MyRun(String StringFromJNIC)
     
    
    
     
      
      
      {
     
    
    
     
      
      
      try
     
    
    
     
      
      
      {
     
    
    
     
      
      
      Log.i("loda:", "in MyJavaClass:" + StringFromJNIC);
      
      
     
    
    
     
      
      
      }
      
      
     
    
    
     
      
      
      catch(Exception e)
     
    
    
     
      
      
      {
      
      
     
    
    
     
      
      
      e.printStackTrace();
     
    
    
     
      
      
      }
     
    
    
     
      
      
      Log.i("loda:","End of MyRun");
     
    
    
     
      
      
      return "From MyJavaClass/MyRun in Java";
     
    
    
     
      
      
      }
     
    
    
     
      }
     
    
    
     
     
    
    
     
      
      
     
     
      透過
     
     
      C
     
     
      程式要啟動
     
     
      Dalvik
     
     
      虛擬器
     
     
      ,
     
     
      會透過呼叫函式
     
     
     
     
      JNI_CreateJavaVM (
     
     
      實作在
     
     
      dalvik/vm/Jni.c
     
     
      中
     
     
      ),
     
     
      之後透過函式
     
     
      dvmStartup(
     
     
      實作在
     
     
      dalvik/vm/Init.c),
     
     
      再呼叫函式
     
     
      dvmPrepMainThread(
     
     
      實作在
     
     
      dalvik/vm/Thread.c)
     
     
      產生
     
     
      Dalvik
     
     
      虛擬器的
     
     
      Main Thread.
     
    
    
     
     
    
    
     
      
      
      Google
     
     
      從
     
     
      2.2
     
     
      版
     
     
      Foryo
     
     
      開始釋出
     
     
      NDK r4
     
     
      的版本
     
     
      ,
     
     
      支援
     
     
      JNI
     
     
      單步除錯的機制
     
     
      .
     
     
      除了可以直接透過
     
     
      JNI
     
     
      介面開發
     
     
     
     
      Java
     
     
      與
     
     
      Native Code
     
     
      的整合應用外
     
     
      ,Google
     
     
      當然也提供了
     
     
      NDK
     
     
      的
     
     
      Framework,
     
     
      讓有這需求的開發者可以有一定程度的規範
     
     
      .
     
    
    
     
      
      
     
    
    
     
      
      
     
     
      接下來
     
     
      ,
     
     
      我們就針對
     
     
      JNI
     
     
      的介面進一步的追蹤系統運作的原理
     
     
      ,
     
    
    
     
     
    
    
     
      
      
     
     
      以
     
     
     
     
      hello-jni
     
     
      範例提供的
     
     
      JNI C
     
     
      函式
     
     
      Java_com_example_hellojni_HelloJni_stringFromJNI
     
     
      為例
     
     
      ,
     
     
      進入到
     
     
     
     
      Java_com_example_hellojni_HelloJni_stringFromJNI
     
     
      函式後
     
     
      ,
     
     
      此時的
     
     
      Call Stack
     
     
      為
     
    
    
     
      (gdb) bt full
     
    
    
     
      #0
      
      
      Java_com_example_hellojni_HelloJni_stringFromJNI (env=0xaa50,thiz=0x43e1d078)
     
    
    
     
      
      
      at C:/cygwin/android-ndk-r5b-windows/samples/hello-jni/jni/hello-jni.c:30
     
    
    
     
      No locals.
     
    
    
     
      #1
      
      
      0x80213978 in ?? ()
     
    
    
     
      確認
     
     
      Registers LR
     
     
      與
     
     
      PC
     
    
    
     
     
    
    
     
      lr
      
      
      0x80213978
      
      
      2149661048
     
    
    
     
      pc
      
      
      0x803002e4
      
      
      0x803002e4 <Java_com_example_hellojni_HelloJni_stringFromJNI+8>;
     
    
    
     
     
    
    
     
      進一步確認上一層記憶體
     
     
      0x80213974
     
     
      中的程式邏輯
     
    
    
     
      0x8021396c:
      
      
      ldmia
      
      
      r9, {r2, r3}
     
    
    
     
      0x80213970:
      
      
      ldr
      
      
      r12, [r4, #8]
     
    
    
     
      0x80213974:
      
      
      blx
      
      
      r12 =>;
     
     
      由此跳到
     
     
      Java_com_example_hellojni_HelloJni_stringFromJNI
     
     
      中執行
     
     
      C
     
     
      函式庫
     
    
    
     
      0x80213978:
      
      
      cmp
      
      
      r5, #0
      
      
      ; 0x0
     
    
    
     
      0x8021397c:
      
      
      ldrne
      
      
      r12, [r4, #12]
     
    
    
     
      0x80213980:
      
      
      stmneia r12, {r0, r1}
     
    
    
     
      0x80213984:
      
      
      ldmdb
      
      
      r4, {r4, r5, r6, r7, r8, r9, sp, pc}
     
    
    
     
      0x80213988:
      
      
      mov
      
      
      r5, r2, lsr #28
     
    
    
     
      0x8021398c:
      
      
      ldr
      
      
      
      
      r6, [r4, #4]
     
    
    
     
      0x80213990:
      
      
      mov
      
      
      r2, #0
      
      
      ; 0x0
     
    
    
     
      0x80213994:
      
      
      ldrb
      
      
      r12, [r6], #1
     
    
    
     
      0x80213998:
      
      
      cmp
      
      
      r12, #0 ; 0x0
     
    
    
     
      0x8021399c:
      
      
      beq
      
      
      0x802139c0
     
    
    
     
      0x802139a0:
      
      
      add
      
      
      r2, r2, #1
      
      
      ; 0x1
     
    
    
     
      0x802139a4:
      
      
      cmp
      
      
      r12, #68
      
      
      ; 0x44
     
    
    
     
      0x802139a8:
      
      
      cmpne
      
      
      r12, #74
      
      
      ; 0x4a
     
    
    
     
      0x802139ac:
      
      
      bne
      
      
      0x80213994
     
    
    
     
     
    
    
     
      由上述的程式碼
     
     
      ,
     
     
      我們可以對應到
     
     
      JNI
     
     
      呼叫到
     
     
      Native Code
     
     
      中的實作代碼是在
     
     
      dalvik/vm/arch/arm/CallEABI.S
     
     
      原始碼中的
     
     
      Lcopy_done
     
     
      程式碼
     
     
      ,
     
     
      負責由
     
     
      Java World
     
     
      呼叫到
     
     
      JNI Native Code
     
    
    
     
     
    
    
     
      .Lcopy_done:
     
    
    
     
      
      
      ...................
     
    
    
     
      
      
      ldmia
      
      
      r9, {r2-r3}
      
      
      @ r2/r3<- argv[0]/argv[1]
     
    
    
     
      
      
      @ call the method
     
    
    
     
      
      
      ldr
      
      
      ip, [r4, #8]
      
      
      @ func
     
    
    
     
      #ifdef __ARM_HAVE_BLX
     
    
    
     
      
      
      blx
      
      
      ip
     
    
    
     
      #else
     
    
    
     
      
      
      mov
      
      
      lr, pc
     
    
    
     
      
      
      bx
      
      
      ip
     
    
    
     
      #endif
     
    
    
     
      
      
      
      
     
    
    
     
      
      
      
      
     
     
      由此溯源
     
     
      ,
     
     
      我們得知函式
     
     
      dvmPlatformInvoke
     
     
      是在
     
     
      Dalvik Vm
     
     
      中負責將
     
     
      Java World
     
     
      與
     
     
      Native World
     
     
      做一個呼叫轉換的函式
     
     
      .
     
     
      參考
     
     
      dalvik/vm/arch
     
     
      中的實作
     
     
      ,Android
     
     
      本身有提供對
     
     
     
     
      arm/sh/x86/x86-atom JNI Calling Convention
     
     
      的組語優化
     
     
      ,
     
     
      如果不是上述平台
     
     
      ,
     
     
      就會透過
     
     
      FFI (Foreign Function Interface)(
     
     
      網址
     
     
      :
      
       http://sourceware.org/libffi/
      
      )
     
     
      函式庫來實作函式
     
     
      dvmPlatformInvoke,
     
     
      達成
     
     
      JNI
     
     
      介面在不同平台上的支援
     
     
      . FFI
     
     
      機制
     
     
      ,
     
     
      提供一個完整的介面
     
     
      ,
     
     
      讓從
     
     
      Interpreter
     
     
      端可以呼叫到原生碼的實作
     
     
      ,
     
     
      包括參數的傳遞
     
     
      ,
     
     
      與對不同平台的支持
     
     
      ,
     
     
      參考網頁
     
     
      ,
     
     
      除了
     
     
      Dalvik JNI
     
     
      介面有採用外
     
     
      ,
     
     
      包括
     
     
      FireFox 3.6/Mac OSX/iPhone JavaScript,Ruby,Python ..etc
     
     
      都有使用這個介面達成由
     
     
      Interpreter
     
     
      呼叫到原生碼的機制
     
     
      .
     
    
    
     
     
    
    
     
     
    
    
     
     
    
    
     
      
       Just-In-Time Compiler
      
     
    
    
     
     
    
    
     
      
      
     
     
      有關
     
     
      JIT
     
     
      把
     
     
      ByteCode
     
     
      轉成原生指令集的概念
     
     
      ,
     
     
      前兩天也聽到同事在聊
     
     
      LLVM(Low level virtual machine,
     
     
      網址
     
     
      
       http://llvm.org/
      
      ),
     
     
      這概念是把
     
     
      C/C++/Fortran
     
     
      的程式語言透過
     
     
      llvm-gcc
     
     
      轉成中介語言
     
     
      ,
     
     
      之後透過
     
     
      LLVM
     
     
      轉換成執行平台原生的指令集
     
     
      ,
     
     
      有關程式碼與中介語言的產生
     
     
      ,
     
     
      可以透過該網站的
     
     
      Demo
     
     
      網頁
     
     
      
       http://llvm.org/demo/index.cgi
      
     
     
      實際的操刀體驗看看
     
     
      .
     
    
    
     
     
    
    
     
      
      
      Dalvik
     
     
      系統除了有
     
     
      Portable
     
     
      與
     
     
      Fast Intepreter
     
     
      實作外
     
     
      ,
     
     
      還可以透過
     
     
      JIT
     
     
      的機制
     
     
      ,
     
     
      實現把
     
     
      Dalvik OpCode
     
     
      轉成原生代碼的機制
     
     
      ,
     
     
      讓運作的效率可以變得更高
     
     
      ,
     
     
      參考
     
     
      dvmMterpStdRun
     
     
      的實作
     
     
      ,
     
     
      我們可以知道
     
     
      JIT
     
     
      在
     
     
      Dalvik
     
     
      中的入口是透過
     
     
      Fast Interpreter,
     
     
      如果你所在平台用的是
     
     
      Portable Interpreter,
     
     
      那
     
     
      JIT
     
     
      的機制也就沒有作用了
     
     
      .(
     
     
      ㄟ
     
     
     
     
      也是啦
     
     
      ,,,,Fast Interpreter
     
     
      就是
     
     
      Dalvik
     
     
      用組語去刻出來的加速
     
     
      Dalvik OpCode
     
     
      直譯器
     
     
      ,
     
     
      如果你不是用
     
     
      ARM
     
     
      或是
     
     
      x86
     
     
      的指令集平台
     
     
      ,
     
     
      或其他第三方有支援
     
     
      Fast Interpreter
     
     
      組語實作的
     
     
      Dalvik
     
     
      版本
     
     
      ,
     
     
      只能採用
     
     
      C
     
     
      版本的實作
     
     
      ,
     
     
      自然也不可能會有
     
     
      JIT
     
     
      機制的實作了
     
     
      .).
     
    
    
     
     
    
    
     
      
      
     
     
      可以參考如下的新聞
     
     
      Android 2.2 Froyo 450% Faster Than Eclair(
     
     
      網頁
     
     
      :
      
       http://www.mobiletopsoft.com/board/7646/android-2-2-froyo-450-faster-than-eclair.html
      
      ),
     
     
      在有開啟
     
     
      JIT
     
     
      的
     
     
      Android 2.2 Froyo
     
     
      版本中
     
     
      ,
     
     
      可以得到比沒有開啟
     
     
      JIT
     
     
      的
     
     
      2.1 Eclair
     
     
      大約
     
     
      4.5
     
     
      倍的
     
     
      Dalvik
     
     
      應用執行效率
     
     
      .(
     
     
      分別為
     
     
      37.5 MFLOPS
     
     
      與
     
     
     
     
      6.5-7 MFLOPS).
     
    
    
     
     
    
    
     
      
      
     
     
      參考
     
     
      Google
     
     
      的文件
     
     
      ,JIT
     
     
      的技術
     
     
      ,
     
     
      有很多種施行的方式
     
     
      ,
     
     
      包括在載入時期編譯
     
     
      ,
     
     
      安裝應用程式時編譯
     
     
      ,
     
     
      函式被呼叫時編譯整個函式
     
     
      ,
     
     
      或是
     
     
      Byte Code
     
     
      指令在被擷取時編譯
     
     
      ,
     
     
      而編譯時
     
     
      ,
     
     
      可以選擇把整個應用程式編譯
     
     
      ,
     
     
      動態函式庫
     
     
      ,
     
     
      針對
     
     
      Class
     
     
      的
     
     
      Method
     
     
      編譯
     
     
      ,Trace-JIT(
     
     
      選擇熱點編譯
     
     
      ),
     
     
      或一次只編譯一個
     
     
      Byte Code
     
     
      指令
     
     
      .Android
     
     
      在選擇
     
     
      JIT
     
     
      技術時
     
     
      ,
     
     
      主要希望以符合移動
     
     
      ,
     
     
      透過電池供電
     
     
      ,
     
     
      最小的記憶體需求
     
     
      (
     
     
      可以參考
     
     
      Jazelle
     
     
      網頁
     
     
      http://www.arm.com/products/processors/technologies/jazelle.php,Java Byte Code to Native Code
     
     
      記憶體會膨脹
     
     
      4-8
     
     
      倍
     
     
      ),
     
     
      要跟既有的
     
     
      Dalvik
     
     
      安全機制共存
     
     
      ,
     
     
      快速達到效能的提升
     
     
      ,
     
     
      能在既有的直譯器
     
     
      (Intepreter)
     
     
      與
     
     
      JIT
     
     
      技術間平順的過渡
     
     
      .
     
     
      一般常見的
     
     
      Java
     
     
      虛擬器
     
     
      (
     
     
      例如
     
     
     
     
      SUN
      
      
      Java HotSpot Virtual Machine)
     
     
      採用的是
     
     
      Method-JIT,
     
     
      而
     
     
      Dalvik
     
     
      採用的是
     
     
      Trace-JIT,
     
     
      兩者的差別如下
     
    
    
     
     
    
    
     
     
    
    
     
     
    
    
     
     
    
    
     
     
    
    
     
      
       
        
         
          Method JIT
         
        
       
       
        
         
          1,
         
         
          目前最常見的
         
         
          JIT
         
         
          機制
         
        
        
         
          2,
         
         
          透過直譯器
         
         
          (Interpreter)
         
         
          去統計出熱門的
         
         
          Class Method
         
        
        
         
          3,
         
         
          編譯與最佳化以
         
         
          Java Class Method
         
         
          為單位
         
        
        
         
          4,
         
         
          有關虛擬器對應到直譯器的資訊
         
         
          ,
         
         
          只需要考慮到所走過的
         
         
          Method
         
         
          為主
         
         
          .
         
        
        
         
          5,
         
         
          缺點在於
         
         
          ,
         
         
          所最佳化的
         
         
          Mehtod
         
         
          中
         
         
          ,
         
         
          可能會包含幾乎用不到的程式碼片段
         
         
          ,
         
         
          由於優化的範圍大
         
         
          ,
         
         
          因此對記憶體需求較高
         
         
          ,
         
         
          在函式一開始執行時
         
         
          ,
         
         
          呼叫到熱門
         
         
          Mehtod,
         
         
          需要有比較長的延遲時間
         
         
          (
         
         
          等待最佳化為機械碼
         
         
          )
         
        
       
      
      
       
        
         
          Trace JIT
         
        
       
       
        
         
          1,
         
         
          透過直譯器去統計熱門的執行路徑
         
         
          (Execution Path)
         
        
        
         
          2,
         
         
          會把編譯的程式碼片段串
         
         
          (Fragment Chain)
         
         
          放到轉譯的
         
         
          Cache
         
         
          中
         
         
          (Dalvik-jit-code-cache)
         
        
        
         
          3,
         
         
          只有最熱門的程式碼執行路徑
         
         
          (
         
         
          片段
         
         
          )
         
         
          會被編譯到
         
         
          ,
         
         
          可以節省記憶體的需求
         
         
          ,
         
         
          並且可以跟直譯器更緊密的結合
         
         
          ,
         
         
          擁有較快速的編譯與執行效能
         
         
          (
         
         
          因為不用根據整個
         
         
          Method
         
         
          去編譯
         
         
          )
         
        
        
         
          4,
         
         
          每個
         
         
          Dalvik
         
         
          行程都有獨立的
         
         
          Dalvik
         
         
          虛擬器
         
         
          ,
         
         
          並擁有一個
         
         
          Translation Cache(
         
         
          用來儲存編譯為機械碼的
         
         
          Trace
         
         
          段落
         
         
          ).
         
        
        
         
          5,
         
         
          缺點在於
         
         
          ,
         
         
          優化的範圍較小
         
         
          ,
         
         
          會跟直譯器互動的頻率高
         
         
          ,
         
         
          並且
         
         
          ,
         
         
          較難以把最佳化過的程式碼片段跨行程分享
         
         
          .(
         
         
          由於不是以
         
         
          Method
         
         
          為單位
         
         
          ,
         
         
          只根據每個
         
         
          Mehtod
         
         
          中的程式碼片段優化
         
         
          ,
         
         
          每個應用程式的行為差異不小
         
         
          ,
         
         
          不過這有一篇交大碩士的論文
         
         
          
           http://www.cis.nctu.edu.tw/~wuuyang/papers/File-Based%20Sharing%20For%20Dynamically%20Compiled%20Code%20On%20Dalvik%20Virtual%20Machine.pdf
          
          ,
         
         
          有提到如何在
         
         
          Dalvik
         
         
          中跨行程分享這優化過的程式碼片段
         
         
          )
         
        
        
         
          6,Android
         
         
          建議把
         
         
          JIT
         
         
          視為直譯器能力的延伸
         
        
        
         
          7,
         
         
          確保
         
         
          Trace
         
         
          段落
         
         
          ,
         
         
          只會包含有成功執行過的
         
         
          Byte Code
         
        
        
         
          8,
         
         
          會根據使用的平台
         
         
          (
         
         
          通常為
         
         
          ARM),
         
         
          優化暫存器的使用
         
         
          ,Load/Store
         
         
          指令的使用
         
         
          (
         
         
          減少需要去外部記憶體存取的成本
         
         
          ),
         
         
          消除不必要的
         
         
          Null-Check.
         
        
        
         
          9,
         
         
          優化
         
         
          Byte Code
         
         
          中
         
         
          Loop
         
         
          迴圈的執行
         
         
          .
         
        
        
         
          10,
         
         
          通常會以一個
         
         
          Branch
         
         
          的目標位址作為一個
         
         
          Trace
         
         
          區塊的頭
         
         
          .(
         
         
          以此為
         
         
          Trace
         
         
          區塊也合理
         
         
          ,
         
         
          便於在
         
         
          Translation Cache
         
         
          與
         
         
          Interpreter
         
         
          之間進行跳躍
         
         
          ).
         
        
       
      
     
    
    
     
     
    
    
     
     
    
    
     
      
      
     
     
      參考這份
     
     
      Android
     
     
      文件
     
     
      
       http://www.android-app-developer.co.uk/android-app-development-docs/android-jit-compiler-androids-dalvik-vm.pdf
      
      ,Android Dalvik
     
     
      基於記憶體需求
     
     
      ,
     
     
      功耗
     
     
      (For
     
     
      移動裝置
     
     
      )
     
     
      與應用程式反應時間
     
     
      ,
     
     
      選擇了
     
     
      Trace-JIT
     
     
      為實作的技術
     
     
      ,
     
     
      運作的機制為
     
     
      ,
     
     
      應用程式先透過
     
     
      Fast Interpreter
     
     
      載入
     
     
      ,
     
     
      依據執行的位置
     
     
      ,
     
     
      更新程式執行統計表格
     
     
      ,,
     
     
      如果該位置沒有達到
     
     
      Threshold,
     
     
      直譯器繼續執行
     
     
      ,
     
     
      直到到達下一個可能的
     
     
      Trace
     
     
      段落
     
     
      ,
     
     
      再度確認統計表格
     
     
      ,
     
     
      是否有達到
     
     
      Threshold,
     
     
      若達到就確認該
     
     
      Trace
     
     
      段落
     
     
      ,
     
     
      是否已經有對應編譯的結果
     
     
      ,
     
     
      如果有就直接跳過去執行
     
     
      ,
     
     
      如果沒有就編譯該
     
     
      Trace
     
     
      段落
     
     
      ,
     
     
      並加入到
     
     
      JIT
     
     
      轉譯快取
     
     
      (Translation Cache)
     
     
      中
     
     
      .
     
     
      位於
     
     
      Translation
     
     
      中的
     
     
      Trace
     
     
      段落編譯結果
     
     
      ,
     
     
      可以依據應用程式的行為彼此呼叫
     
     
      ,
     
     
      如果該編譯段落的下一段
     
     
      Trace Fragment
     
     
      並不在
     
     
      Translation Cache
     
     
      中
     
     
      ,
     
     
      就直接呼叫回直譯器執行該
     
     
      Trace Fragment,
     
     
      繼續
     
     
      Dalvik
     
     
      應用程式的執行
     
     
      .
     
    
    
     
     
    
    
     
      
      
      ARMv5te
     
     
      架構下
     
     
     
     
      gDvmJit.threshold = 200 (in Sorce Code compiler/codegen/arm/armv5te/ArchVariant.c),
     
     
      而
     
     
      ARMv7a
     
     
      架構下
     
     
     
     
      gDvmJit.threshold = 40 ( compiler/codegen/arm/armv7-a/ArchVariant.c),
     
     
      以此來看
     
     
      ,
     
     
      處理器的時脈越高
     
     
      ,Android
     
     
      對於
     
     
      Trace
     
     
      區塊
     
     
      Threshold
     
     
      的要求就越低
     
     
      ,
     
     
      也就是會盡可能都透過
     
     
      JIT
     
     
      編譯讓運作環境更快
     
     
      .(
     
     
      當然也表示對同一
     
     
      Android
     
     
      區塊
     
     
      ,JIT
     
     
      的編譯時間越短
     
     
      ).
     
    
    
     
     
    
    
     
      
      
     
     
      參考
     
     
      Android
     
     
      文件
     
     
      (
     
     
      抱歉
     
     
      ,,
     
     
      我就不自己
     
     
      OProfile
     
     
      了
     
     
      ...@_@),Dalvik JIT
     
     
      對
     
     
      Trace
     
     
      段落熱區的統計
     
     
      ,
     
     
      可以達到有
     
     
      97%
     
     
      是落在
     
     
      Translation Cache(Dalvik-jit-code-cache)
     
     
      中
     
     
      (
     
     
      在
     
     
      Cache
     
     
      中的
     
     
      Trace
     
     
      段落可以彼此呼叫
     
     
      ,
     
     
      直到遇到不在
     
     
      Cache
     
     
      中的
     
     
      Trace
     
     
      段落才需要回到
     
     
      Interpreter),
     
     
      只有
     
     
      3%
     
     
      需要透過
     
     
      Fast Interpreter (Libdvm.so)
     
     
      執行
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      承上
     
     
      ,
     
     
      以
     
     
      system_server
     
     
      為例
     
     
      ,
     
     
      在開機後
     
     
      20
     
     
      分鐘
     
     
      ,
     
     
      大約有
     
     
      9898
     
     
      個
     
     
      Trace
     
     
      段落被編譯
     
     
      ,
     
     
      總共佔
     
     
      Byte Code
     
     
      大小約
     
     
      103966bytes(
     
     
      平均每個
     
     
      Trace
     
     
      段落
     
     
      Byte Code
     
     
      約
     
     
      11bytes),
     
     
      編譯需要時間約
     
     
      6.024
     
     
      秒
     
     
      ,
     
     
      編譯後的機械碼大小為
     
     
      796264 bytes (
     
     
      平均每個
     
     
      Trace
     
     
      段落轉成機械碼約
     
     
      80bytes),
     
     
      所涉及的
     
     
      Method Byte Code
     
     
      程式碼大小為
     
     
      396230 bytes(
     
     
      如果用
     
     
      Trace-JIT
     
     
      可以省去編譯
     
     
      2.8
     
     
      倍的
     
     
      ByteCode
     
     
      範圍
     
     
      ),
     
     
      相對於省去的
     
     
      JIT
     
     
      機械碼大小就更可觀了
     
     
      (Method Byte Code
     
     
      程式碼大小
     
     
      :396230 bytes
     
     
      乘上
     
     
      7
     
     
      倍
     
     
      (
     
     
      約
     
     
      80/11)=2773610bytes,
     
     
      約可省下編譯後約
     
     
      1.977364MB).
      
      
     
    
    
     
     
    
    
     
      
      
      Dalvik
     
     
      在選擇
     
     
      JIT Trace
     
     
      區塊的時候
     
     
      ,
     
     
      會在以下
     
     
      OpCode
     
     
      中進行
     
     
      Profile
     
     
      的統計
     
     
      ,
     
     
      找出熱門的執行
     
     
      Trace
     
     
      區塊
     
     
      (
     
     
      參考
     
     
     
     
      dalvik/vm/mterp/out/InterpAsm-armv5te.S
     
     
      實作
     
     
      ),
     
     
      作為
     
     
      Trace
     
     
      區塊的
     
     
      Head.
     
    
    
     
      
      
     
    
    
     
      
       
        
         
          指令集名稱
         
        
       
       
        
         
          編碼
         
        
       
      
      
       
        
         
          OP_GOTO
         
        
       
       
        
         
          0x28
         
        
       
      
      
       
        
         
          OP_GOTO_16
         
        
       
       
        
         
          0x29
         
        
       
      
      
       
        
         
          OP_GOTO_32
         
        
       
       
        
         
          0x2a
         
        
       
      
      
       
        
         
          OP_PACKED_SWITCH
         
        
       
       
        
         
          0x2b
         
        
       
      
      
       
        
         
          OP_SPARSE_SWITCH
         
        
       
       
        
         
          0x2c
         
        
       
      
      
       
        
         
          OP_IF_EQ
         
        
       
       
        
         
          0x32
         
        
       
      
      
       
        
         
          OP_IF_NE
         
        
       
       
        
         
          0x33
         
        
       
      
      
       
        
         
          OP_IF_LT
         
        
       
       
        
         
          0x34
         
        
       
      
      
       
        
         
          OP_IF_GE
         
        
       
       
        
         
          0x35
         
        
       
      
      
       
        
         
          OP_IF_GT
         
        
       
       
        
         
          0x36
         
        
       
      
      
       
        
         
          OP_IF_LE
         
        
       
       
        
         
          0x37
         
        
       
      
      
       
        
         
          OP_IF_EQZ
         
        
       
       
        
         
          0x38
         
        
       
      
      
       
        
         
          OP_IF_NEZ
         
        
       
       
        
         
          0x39
         
        
       
      
      
       
        
         
          OP_IF_LTZ
         
        
       
       
        
         
          0x3a
         
        
       
      
      
       
        
         
          OP_IF_GEZ
         
        
       
       
        
         
          0x3b
         
        
       
      
      
       
        
         
          OP_IF_GTZ
         
        
       
       
        
         
          0x3c
         
        
       
      
      
       
        
         
          OP_IF_LEZ
         
        
       
       
        
         
          0x3d
         
        
       
      
     
    
    
     
     
    
    
     
     
    
    
     
      
      
     
     
      我們舉實際的例子來說明
     
     
      ,
     
     
      不過首先定義一下
     
     
      ,
     
    
    
     
      在
     
     
      ARM EABI GCC
     
     
      編譯器中
     
     
      ,
     
     
      對於
     
     
      ARM
     
     
      暫存器的識別名稱
     
    
    
     
     
    
    
     
      
       
        
         
          暫存器
         
        
       
       
        
         
          識別名稱
         
        
       
       
        
         
          說明
         
        
       
      
      
       
        
         
          r10
         
        
       
       
        
         
          sl
         
        
       
       
        
         
          seems to be generally available
         
        
       
      
      
       
        
         
          r11
         
        
       
       
        
         
          fp
         
        
       
       
        
         
          is used by gcc (unless -fomit-frame-pointer is set)
         
        
       
      
      
       
        
         
          r12
         
        
       
       
        
         
          ip
         
        
       
       
        
         
          is scratch -- not preserved across method calls
         
        
       
      
      
       
        
         
          r13
         
        
       
       
        
         
          sp
         
        
       
       
        
         
          should be managed carefully in case a signal arrives
         
        
       
      
      
       
        
         
          r14
         
        
       
       
        
         
          lr
         
        
       
       
        
         
          must be preserved
         
        
       
      
      
       
        
         
          r15
         
        
       
       
        
         
          pc
         
        
       
       
        
         
          can be tinkered with directly
         
        
       
      
     
    
    
     
     
    
    
     
      在
     
     
      Fast Interpreter
     
     
      中
     
     
      ,
     
     
      對於
     
     
      ARM
     
     
      暫存器的使用與識別名稱
     
    
    
     
     
    
    
     
      
       
        
         
          暫存器
         
        
       
       
        
         
          識別名稱
         
        
       
       
        
         
          說明
         
        
       
      
      
       
        
         
          r4
         
        
       
       
        
         
          rPC
         
        
       
       
        
         
          interpreted program counter, used for fetching instructions
         
        
       
      
      
       
        
         
          r5
         
        
       
       
        
         
          rFP
         
        
       
       
        
         
          interpreted frame pointer, used for accessing locals and args
         
        
       
      
      
       
        
         
          r6
         
        
       
       
        
         
          rGLUE
         
        
       
       
        
         
          MterpGlue pointer
         
        
       
      
      
       
        
         
          r7
         
        
       
       
        
         
          rINST
         
        
       
       
        
         
          first 16-bit code unit of current instruction
         
        
       
      
      
       
        
         
          r8
         
        
       
       
        
         
          rIBASE
         
        
       
       
        
         
          interpreted instruction base pointer, used for computed goto
         
        
       
      
     
    
    
     
     
    
    
     
      
      
     
     
      還有參考
     
     
      dalvik/vm/Globals.h
     
     
      中對於
     
     
      gDvmJit
     
     
      的宣告
     
     
      “extern struct DvmJitGlobals gDvmJit;”,
     
     
      其中
     
     
     
     
      DvmJitGlobals
     
     
      定義了
     
     
      JIT
     
     
      運作時
     
     
      ,
     
     
      所需的相關變數與狀態資訊
     
     
      .
     
     
      以及
     
     
      dalvik/vm/Thread.h
     
     
      中對於
     
     
      Thread
     
     
      的宣告
     
     
      ,
     
     
      建議可以一併理解
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      參考
     
     
     
     
      dalvik/vm/mterp/common/asm-constants.h
     
     
      中
     
     
      ,
     
     
      關於組語中會用到的變數定義
     
     
      ,
     
     
      同時參考
     
     
      dalvik/vm/mterp/Mterp.h
     
     
      中的宣告
     
     
     
     
      "typedef InterpState MterpGlue;”
     
     
      與在原始碼
     
     
     
     
      dalvik/vm/interp/InterpDefs.h
     
     
      中關於
     
     
      “typedef struct InterpState”
     
     
      的原型
     
     
      ,
     
     
      我定義幾個在後續說明時
     
     
      ,
     
     
      會用到的
     
     
      MterpGlue struct
     
     
      參數名稱與說明
     
    
    
     
     
    
    
     
     
    
    
     
      
       
        
         
          
           ARM
          
         
         
          
           組語中的名稱
          
         
         
         
        
       
       
        
         
          
           C
          
         
         
          
           程式碼中的變數名稱
          
         
         
         
        
       
       
        
         
          
           說明
          
         
         
         
        
       
      
      
       
        
         
          offGlue_pJitProfTable
         
        
       
       
        
         
          pJitProfTable
         
        
       
       
        
         
          Array of profile threshold counters
         
        
       
      
      
       
        
         
          offGlue_jitThreshold
         
        
       
       
        
         
          jitThreshold
         
        
       
       
        
         
          為判斷該目標位置
         
         
          ,
         
         
          是否已達可進行
         
         
          JIT
         
         
          編譯為原生碼的要求
         
         
          ,
         
         
          以筆者手中的版本來說
         
         
          ,armv5te-vfp/armv5te
         
         
          定義為
         
         
          200,
         
         
          而
         
         
          armv7-a-neon/armv7-a
         
         
          定義為
         
         
          40
         
         
          即達可進行
         
         
          JIT
         
         
          編譯的門檻
         
         
          .
         
        
       
      
      
       
        
         
         
        
       
       
        
         
          pJitEntryTable
         
        
       
       
        
         
          會透過
         
         
          JIT Hash
         
         
          機制
         
         
          ,
         
         
          用來儲存在
         
         
          Fast Interpret
         
         
          中有被編譯為原生碼的目標位置
         
         
          Trace
         
         
          段落
         
         
          .
         
        
       
      
      
       
        
         
          offThread_inJitCodeCache
         
        
       
       
        
         
          inJitCodeCache
         
        
       
       
        
         
          相對於每個
         
         
          Dalvik Thread,
         
         
          用來儲存對應的
         
         
          Trace
         
         
          區塊編譯後的原生碼記憶體位址
         
        
       
      
      
       
        
         
          offGlue_jitState
         
        
       
       
        
         
          jitState
         
        
       
       
        
         
          設定
         
         
          Debug
         
         
          或要取
         
         
          Trace
         
         
          區塊時
         
         
          ,Interpreter
         
         
          所在的狀態
         
         
          ,
         
         
          可以包括以下的屬性
         
        
        
         
          kJitNot = 0,
          
          
          // Non-JIT related reasons */
         
        
        
         
          kJitTSelectRequest = 1,
          
          
          // Request a trace (subject to filtering)
         
        
        
         
          kJitTSelectRequestHot = 2, // Request a hot trace (bypass the filter)
         
        
        
         
          kJitSelfVerification = 3,
          
          
          // Self Verification Mode
         
        
        
         
          
          
         
        
        
         
          /* Operational states in the debug interpreter */
         
        
        
         
          kJitTSelect = 4,
          
          
          // Actively selecting a trace
         
        
        
         
          kJitTSelectEnd = 5,
          
          
          // Done with the trace - wrap it up
         
        
        
         
          kJitSingleStep = 6,
          
          
          // Single step interpretation
         
        
        
         
          kJitSingleStepEnd = 7,
          
          
          // Done with single step, ready return to mterp
         
        
        
         
          kJitDone = 8,
          
          
          // Ready to leave the debug interpreter
         
        
       
      
      
       
        
         
         
        
       
       
        
         
          InterpEntry
         
        
       
       
        
         
          組語的宣告
         
        
        
         
          MTERP_CONSTANT(kInterpEntryInstr,
          
          
          0)
         
        
        
         
          MTERP_CONSTANT(kInterpEntryReturn,
          
          
          1)
         
        
        
         
          MTERP_CONSTANT(kInterpEntryThrow,
          
          
          2)
         
        
        
         
          MTERP_CONSTANT(kInterpEntryResume,
          
          
          3)
         
        
        
         
          C
         
         
          的宣告
         
        
        
         
          kInterpEntryInstr = 0,
          
          
          // continue to next instruction
         
        
        
         
          kInterpEntryReturn = 1,
          
          
          // jump to method return
         
        
        
         
          kInterpEntryThrow = 2,
          
          
          // jump to exception throw
         
        
        
         
          kInterpEntryResume = 3,
          
          
          // Resume after single-step
         
        
       
      
      
       
        
         
          offGlue_entryPoint
         
        
       
       
        
         
          entryPoint
         
        
       
       
        
         
          用來儲存所要去的
         
         
          Interpreter
         
        
       
      
     
    
    
     
     
    
    
     
     
    
    
     
     
    
    
     
      
      
     
     
      接下來
     
     
      ,
     
     
      進行流程上的說明
     
     
      ,
     
     
      在
     
     
      OP_GOTO
     
     
      中
     
     
      ,
     
     
      如果有加入
     
     
      JIT
     
     
      的支援就會
     
     
      ,
     
     
      加入這段
     
     
      Code (
     
     
      我會把認為流程上可以忽略的
     
     
      Code “....”
     
     
      掉
     
     
      )
     
    
    
     
     
    
    
     
      
      
      mov
      
      
      r0, rINST, lsl #16
      
      
      @ r0<- AAxx0000
     
    
    
     
      
      
      movs
      
      
      r9, r0, asr #24
      
      
      @ r9<- ssssssAA (sign-extended)
     
    
    
     
      
      
      mov
      
      
      r9, r9, lsl #1
      
      
      @ r9<- byte offset
      
       
        =>;r9
       
      
     
     
      
       
        儲存
       
       
        Goto
       
      
     
     
      
       
        要跳去的
       
       
        Offset
       
      
     
     
      
       
        值
       
      
     
    
    
     
      
      
      
       
        =>;
       
      
     
     
      
       
        如果
       
       
        r9
       
      
     
     
      
       
        為負數
       
       
        ,
       
      
     
     
      
       
        表示會往低位址跳
       
       
        ,
       
      
     
     
      
       
        會跳到函式
       
       
       
       
        common_backwardBranch
       
      
     
     
      
       
        中執行
       
      
     
    
    
     
      
      
      bmi
      
      
      common_backwardBranch
      
      
      @ backward branch, do periodic checks
     
    
    
     
      
      
      
       
        =>;
       
      
     
     
      
       
        如果
       
       
        r9
       
      
     
     
      
       
        為正數
       
       
        ,
       
      
     
     
      
       
        就繼續執行
       
      
     
    
    
     
      #if defined(WITH_JIT)
     
    
    
     
      
      
      GET_JIT_PROF_TABLE(r0)
     
    
    
     
      
      
      FETCH_ADVANCE_INST_RB(r9)
      
      
      @ update rPC, load rINST
     
    
    
     
      
      
      cmp
      
      
      r0,#0
     
    
    
     
      
      
      bne
      
      
      common_updateProfile
     
    
    
     
      
      
      GET_INST_OPCODE(ip)
      
      
      @ extract opcode from rINST
     
    
    
     
      
      
      GOTO_OPCODE(ip)
      
      
      @ jump to next instruction
     
    
    
     
      #else
     
    
    
     
      
      
      …...
     
    
    
     
      #endif
     
    
    
     
     
    
    
     
      
      
     
     
      其中函式
     
     
      common_backwardBranch
     
     
      的實作如下
     
     
      ,
     
    
    
     
     
    
    
     
      common_backwardBranch:
     
    
    
     
      
      
      mov
      
      
      r0, #kInterpEntryInstr
     
    
    
     
      
      
      …...
     
    
    
     
      #if defined(WITH_JIT)
     
    
    
     
      
      
      GET_JIT_PROF_TABLE(r0)
     
    
    
     
      
      
      FETCH_ADVANCE_INST_RB(r9)
      
      
      @ update rPC, load rINST
     
    
    
     
      
      
      cmp
      
      
      r0,#0
     
    
    
     
      
      
      bne
      
      
      common_updateProfile
     
    
    
     
      
      
      GET_INST_OPCODE(ip)
     
    
    
     
      
      
      
      
      GOTO_OPCODE(ip)
     
    
    
     
      #else
     
    
    
     
      
      
      …...
     
    
    
     
      #endif
     
    
    
     
     
    
    
     
     
    
    
     
      
      
     
     
      巨集
     
     
     
     
      FETCH_ADVANCE_INST_RB(
     
     
      宣告為
     
     
      #define FETCH_ADVANCE_INST_RB(_reg) ldrh
      
      
      rINST, [rPC, _reg]!),
     
     
      會把帶入的
     
     
      GOTO
     
     
      目標偏移植
     
     
      (Offset)
     
     
      當做
     
     
      rPC(rPC
     
     
      為
     
     
      Fast Interpreter
     
     
      中的
     
     
      Program Counter)
     
     
      的偏移植
     
     
      ,
     
     
      並把指令存在
     
     
      rINST,
     
     
      與更新下一個指令位置到
     
     
      rPC
     
     
      中
     
     
      .
     
     
      巨集
     
     
      GET_JIT_PROF_TABLE (
     
     
      宣告為
     
     
     
     
      #define GET_JIT_PROF_TABLE(_reg)
      
      
      ldr
      
      
      _reg,[rGLUE,#offGlue_pJitProfTable]),
     
     
      會傳回目前
     
     
      Profile Threshold Counters
     
     
      表格的記憶體位置
     
     
      ,
     
     
      如果該值為
     
     
      0,
     
     
      表示目前並沒有啟動指令
     
     
      Profiling Threshold
     
     
      的機制
     
     
      ,
     
     
      就執行原本
     
     
      Fast Interpreter
     
     
      的流程
     
     
      ,
     
     
      如果該值不為
     
     
      0,
     
     
      就表示
     
     
      JIT
     
     
      的
     
     
      Profiling Threshold
     
     
      機制有開啟
     
     
      ,
     
     
      就跳到函式
     
     
      common_updateProfile
     
     
      進行處理
     
     
      .
     
     
      如下所示
     
     
      
      
     
    
    
     
     
    
    
     
      common_updateProfile:
     
    
    
     
      
      
      
       
        =>;rPC
       
      
     
     
      
       
        儲存的是
       
       
        GOTO
       
      
     
     
      
       
        要去執行的目標位置
       
      
     
    
    
     
      
      
      eor
      
      
      r3,rPC,rPC,lsr #12 @ cheap, but fast hash function
     
    
    
     
      
      
      
       
        =>;
       
      
     
     
      
       
        在筆者
       
       
        ARM_ARCH_5TE
       
      
     
     
      
       
        組態中
       
       
        ,JIT_PROF_SIZE_LOG_2=9,
       
      
     
     
      
       
        其它平台為
       
       
        11
       
      
     
    
    
     
      
      
      lsl
      
      
      r3,r3,#(32 - JIT_PROF_SIZE_LOG_2)
      
      
      @ shift out excess bits
     
    
    
     
      
      
      
       
        =>;
       
      
     
     
      
       
        以在
       
       
        Fast Interpreter
       
      
     
     
      
       
        中的
       
       
        Program Counter
       
      
     
     
      
       
        對
       
       
        Profile Threshold Counters
       
      
     
     
      
       
        表格
       
       
        (
       
      
     
     
      
       
        位置在
       
       
        r0)
       
      
     
     
      
       
        做
       
       
        Hash,
       
      
     
     
      
       
        然後把目前目標位置的
       
       
        Threshold
       
      
     
     
      
       
        值
       
       
        ,
       
      
     
     
      
       
        放到
       
       
        r1
       
      
     
    
    
     
      
      
      ldrb
      
      
      r1,[r0,r3,lsr #(32 - JIT_PROF_SIZE_LOG_2)] @ get counter
     
    
    
     
      
      
      
       
        =>;
       
      
     
     
      
       
        把
       
       
        rINST & 0xff
       
      
     
     
      
       
        存到
       
       
       
       
        r12
       
      
     
     
      
       
        中
       
       
        ,
       
      
     
     
      
       
        成為一個
       
       
       
       
        Dalvik OpCode
       
      
     
    
    
     
      
      
      GET_INST_OPCODE(ip)
     
    
    
     
      
      
      subs
      
      
      r1,r1,#1
      
      
      @ decrement counter
     
    
    
     
      
      
      strb
      
      
      r1,[r0,r3,lsr #(32 - JIT_PROF_SIZE_LOG_2)] @ and store it
     
    
    
     
      
      
      
       
        =>;
       
      
     
     
      
       
        如果
       
       
        r1
       
      
     
     
      
       
        不為
       
       
        0,
       
      
     
     
      
       
        就直接跳到該
       
       
        Dalvik OpCode
       
      
     
     
      
       
        所在的位址
       
       
        ,
       
      
     
     
      
       
        表示該目標位置尚未達
       
       
        Threshold
       
      
     
     
      
       
        的要求
       
       
        ,
       
      
     
     
      
       
        還是執行
       
       
        Fast Interpreter
       
      
     
     
      
       
        的原本機制
       
       
        ,
       
      
     
     
      
       
        不編譯為原生碼
       
       
        .
       
      
     
    
    
     
      
      
      GOTO_OPCODE_IFNE(ip)
      
      
      @ if not threshold, fallthrough otherwise */ (CPSR.Z=0)
     
    
    
     
     
    
    
     
      
      
       
        =>;
       
      
     
     
      
       
        如果
       
       
        r1
       
      
     
     
      
       
        為
       
       
        0,
       
      
     
     
      
       
        就繼續執行
       
       
        ,
       
      
     
     
      
       
        根據
       
       
        Trace
       
      
     
     
      
       
        區塊
       
       
        ,
       
      
     
     
      
       
        進行編譯的流程
       
       
        .
        
       
      
     
     
      …..........................
     
    
    
     
     
    
    
     
      
      
      
       
        =>;
       
      
     
     
      
       
        取得目前平台預設的
       
       
        Threshold
       
      
     
     
      
       
        數值
       
      
     
    
    
     
      
      
      GET_JIT_THRESHOLD(r1)
     
    
    
     
      
      
      ldr
      
      
      r10, [rGLUE, #offGlue_self] @ callee saved r10 <- glue->;self
     
    
    
     
      
      
      
       
        =>;
       
      
     
     
      
       
        重設該目標位置的
       
       
        Threshold Counter,ARMv5
       
      
     
     
      
       
        預設是
       
       
        200,ARMv7
       
      
     
     
      
       
        預設是
       
       
        40
       
      
     
    
    
     
      
      
      strb
      
      
      r1,[r0,r3,lsr #(32 - JIT_PROF_SIZE_LOG_2)] @ reset counter
     
    
    
     
      
      
      
       
        =>;
       
      
     
     
      
       
        把
       
       
        Fast Interpreter
       
      
     
     
      
       
        要去執行的目標位置
       
       
        ,
       
      
     
     
      
       
        存到
       
       
        Interpreted Frame(Stack)
       
      
     
     
      
       
        中
       
      
     
    
    
     
      
      
      EXPORT_PC()
     
    
    
     
      
      
      mov
      
      
      r0,rPC
     
    
    
     
      
      
      bl
      
      
      dvmJitGetCodeAddr
      
      
      @ r0<- dvmJitGetCodeAddr(rPC)
     
    
    
     
      
      
      
       
        =>;
       
      
     
     
      
       
        呼叫函式
       
       
        dvmJitGetCodeAddr ,
       
      
     
     
      
       
        如果位於
       
       
        Fast Interpreter
       
      
     
     
      
       
        的
       
       
        Program Counter
       
      
     
     
      
       
        已經有被編譯過
       
       
        ,
       
      
     
     
      
       
        並儲存在
       
       
        Translation Cache
       
      
     
     
      
       
        中
       
       
        ,
       
      
     
     
      
       
        就傳回對應的記憶體位置
       
      
     
    
    
     
      
      
      str
      
      
      r0, [r10, #offThread_inJitCodeCache] @ set the inJitCodeCache flag
     
    
    
     
      
      
      
       
        =>;
       
      
     
     
      
       
        把編譯過的
       
       
        Code Cache
       
      
     
     
      
       
        記憶體位址儲存在
       
       
        #offGlue_self
       
      
     
     
      
       
        中的
       
       
        #offThread_inJitCodeCache
       
      
     
     
      
       
        欄位中
       
      
     
    
    
     
      
      
      mov
      
      
      r1, rPC
      
      
      @ arg1 of translation may need this
     
    
    
     
      
      
      mov
      
      
      lr, #0
      
      
      @
      
      
      in case target is HANDLER_INTERPRET
     
    
    
     
      
      
      cmp
      
      
      r0,#0
     
    
    
     
      
      
      
       
        =>;
       
      
     
     
      
       
        如果
       
       
        r0
       
      
     
     
      
       
        為
       
       
        0,
       
      
     
     
      
       
        表示尚未編譯過
       
       
        ,
       
      
     
     
      
       
        反之表示編譯過
       
       
        ,
       
      
     
     
      
       
        存在
       
       
        Translation Cache
       
      
     
     
      
       
        中
       
      
     
    
    
     
      #if !defined(WITH_SELF_VERIFICATION)
     
    
    
     
      
      
      ...............
     
    
    
     
      #else
     
    
    
     
      
      
      
       
        =>;
       
      
     
     
      
       
        如果目前
       
       
        Fast Interpreter
       
      
     
     
      
       
        要去的
       
       
        Program Counter
       
      
     
     
      
       
        尚未編譯過
       
       
        ,
       
      
     
     
      
       
        就設定
       
       
        r2
       
      
     
     
      
       
        為
       
       
        selectTrace Request
       
      
     
     
      
       
        然後呼叫函式
       
       
        common_selectTrace
       
      
     
    
    
     
      
      
      moveq
      
      
      r2,#kJitTSelectRequest
      
      
      @ ask for trace selection
     
    
    
     
      
      
      beq
      
      
      common_selectTrace
     
    
    
     
      
      
      /*
     
    
    
     
      
      
      * At this point, we have a target translation.
      
      
      However, if
     
    
    
     
      
      
      * that translation is actually the interpret-only pseudo-translation
     
    
    
     
      
      
      * we want to treat it the same as no translation.
     
    
    
     
      
      
      */
     
    
    
     
      
      
      mov
      
      
      r10, r0
      
      
      @ save target
     
    
    
     
      
      
      bl
      
      
      dvmCompilerGetInterpretTemplate
     
    
    
     
      
      
      cmp
      
      
      r0, r10
      
      
      @ special case?
     
    
    
     
      
      
      bne
      
      
      jitSVShadowRunStart
      
      
      @ set up self verification shadow space
     
    
    
     
      
      
      GET_INST_OPCODE(ip)
     
    
    
     
      
      
      GOTO_OPCODE(ip)
     
    
    
     
      
      
      /* no return */
     
    
    
     
      #endif
     
    
    
     
     
    
    
     
      
      
      
      
     
     
      巨集
     
     
      GET_JIT_THRESHOLD (
     
     
      宣告為
     
     
      #define GET_JIT_THRESHOLD(_reg)
      
      
      ldr
      
      
      _reg,[rGLUE,#offGlue_jitThreshold]),
     
     
      巨集
     
     
     
     
      EXPORT_PC(
     
     
      宣告為
     
     
     
     
      #define EXPORT_PC()
      
      
      str
      
      
      rPC, [rFP, #(-sizeofStackSaveArea + offStackSaveArea_currentPc)]),
     
     
      由函式
     
     
      common_selectTrace
     
     
      會先回到函式
     
     
      dvmMterpStd
     
     
      中
     
     
      (
     
     
      為標準的
     
     
      mterp
     
     
      進入點
     
     
      ,
     
     
      實作位置在
     
     
     
     
      dalvik/vm/mterp/Mterp.c),
     
     
      並設定
     
     
      glue->;nextMode = INTERP_DBG
     
     
      與傳回
     
     
      true,
     
     
      之後回到函式
     
     
      dvmInterpret(
     
     
      實作的位置在
     
     
      dalvik/vm/interp/Interp.c),
     
     
      因為選擇了
     
     
      Debug
     
     
      版本的
     
     
      Interpreter,
     
     
      呼叫進入
     
     
      dvmInterpretDbg(
     
     
      定義為
     
     
      #define INTERP_FUNC_NAME dvmInterpretDbg ),
     
     
      在函式
     
     
      INTERP_FUNC_NAME(
     
     
      實作在
     
     
      dalvik/vm/mterp/out/InterpC-portdbg.c),
     
     
      再呼叫函式
     
     
      dvmJitCheckTraceRequest(
     
     
      實作在
     
     
      dalvik/vm/interp/Jit.c),
     
     
      再透過函式
     
     
      setTraceConstruction
     
     
      進行
     
     
      Trace
     
     
      的建置
     
     
      ,
     
     
      最後呼叫函式
     
     
      dvmCheckJit(
     
     
      實作在
     
     
      dalvik/vm/interp/Jit.c)
     
     
      會一次
     
     
      Interpreter
     
     
      切換週期
     
     
      (
     
     
      由
     
     
      Fast Interpreter
     
     
      切到
     
     
      Debug Interpreter),
     
     
      增加一個指令集的方式進行
     
     
      Trace
     
     
      流程的追蹤
     
     
      ,
     
     
      目前一個
     
     
      Trace
     
     
      流程最多可以有
     
     
      64
     
     
      個
     
     
      TraceRun(MAX_JIT_RUN_LEN=64),
     
     
      也就是說如果你是在函式內
     
     
      GOTO
     
     
      到不同位置的話
     
     
      ,
     
     
      這些路徑就會被當做個別的
     
     
      TraceRun,
     
     
      最後
     
     
      ,
     
     
      放到同一個
     
     
      Trace
     
     
      流程中
     
     
      .
     
     
      如果是在有
     
     
      Switch
     
     
      操作的函式中
     
     
      ,TraceRun
     
     
      的選擇會以一個
     
     
      Switch
     
     
      內的處理指令流程為主
     
     
      ,
     
     
      如果離開所在的
     
     
      Switch
     
     
      判斷
     
     
      ,
     
     
      就會作為一個
     
     
      Trace
     
     
      流程的結束
     
     
      .
     
     
      在
     
     
      dvmCheckJit
     
     
      內部會有以下的判斷依據
     
    
    
     
     
    
    
     
      
      
      1,
     
     
      如果目前已執行
     
     
      Trace
     
     
      指令個數長度不為
     
     
      0,
     
     
      且上一次處理的指令為
     
     
      OP_PACKED_SWITCH
     
     
      或
     
     
      OP_SPARSE_SWITCH,
     
     
      就會將
     
     
      Trace
     
     
      流程結束
     
     
      .
     
    
    
     
      
      
      2,
     
     
      如果上一個指令不是
     
     
      GOTO,
     
     
      也不為
     
     
      INVOKE_DIRECT_EMPTY ,
     
     
      而屬於像是
     
     
      IF/Switch/Return/Invoke
     
     
      類的指令
     
     
      ,
     
     
      也會作為一個
     
     
      Trace
     
     
      流程的結束
     
     
      .
     
    
    
     
      
      
      3,
     
     
      如果上一個指令是一個
     
     
      Exception
     
     
      或是一個
     
     
      Self-Loop,
     
     
      也會作為一個
     
     
      Trace Run
     
     
      的結束
     
     
     
     
      .
     
    
    
     
      
      
      4,
     
     
      如果
     
     
      Trace
     
     
      的指令個數超過
     
     
      100
     
     
      個
     
     
      (JIT_MAX_TRACE_LEN=100),
     
     
      也會當做一個
     
     
      Trace
     
     
      流程的結束
     
     
      .
     
    
    
     
      
      
      5,
     
     
      如果前一個指令為
     
     
      Return,
     
     
      也會當做一個
     
     
      Trace
     
     
      流程的結束
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      當上述
     
     
      Trace
     
     
      流程結束就會把
     
     
      interpState->;jitState
     
     
      設定為
     
     
     
     
      kJitTSelectEnd,
     
     
      或是直接進入到
     
     
      switch
      
      
      kJitTSelectEnd
     
     
      中
     
     
      ,
     
     
      結束
     
     
      Trace
     
     
      流程
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      在函式
     
     
      dvmCheckJit
     
     
      中會判斷
     
     
      ,
     
     
      如果是第一個
     
     
      Trace
     
     
      區塊的指令
     
     
      ,
     
     
      會把當前的
     
     
      Program Counter
     
     
      記錄在
     
     
      interpState->;lastPC,
     
     
      然後
     
     
      ,
     
     
      直接結束
     
     
      .
     
     
      第二次進來時
     
     
      ,
     
     
      會呼叫
     
     
      dexDecodeInstruction(
     
     
      實作在
     
     
      dalvik/libdex/InstrUtils.c)
     
     
      把上一次的
     
     
      Program Counter
     
     
      進行指令集的
     
     
      Decode,
     
     
      如果解碼後的指令為
     
     
      OP_PACKED_SWITCH
     
     
      或是
     
     
      OP_SPARSE_SWITCH,
     
     
      就會設定
     
     
      interpState->;jitState = kJitTSelectEnd
     
     
      把
     
     
      Trace
     
     
      區塊做一個結束
     
     
      .
     
     
      若繼續執行
     
     
      ,
     
     
      就會透過函式
     
     
      dexGetInstrFlags(Inline
     
     
      函式宣告在
     
     
      libdex/InstrUtils.h
     
     
      中
     
     
      ),
     
     
      並依據指令集的
     
     
      OpCode
     
     
      決定
     
     
      Flags
     
     
      為以下的值之一
     
    
    
     
     
    
    
     
     
    
    
     
      
       
        
         
          Dalvik
         
         
          指令
         
        
       
       
        
         
          對應到的
         
         
          Flags
         
         
          狀態
         
        
       
      
      
       
        
         
          OP_NOP,OP_MOVE,OP_MOVE_FROM16,OP_MOVE_16,OP_MOVE_WIDE,
         
        
        
         
          OP_MOVE_WIDE_FROM16,OP_MOVE_WIDE_16,OP_MOVE_OBJECT,
         
        
        
         
          OP_MOVE_OBJECT_FROM16,OP_MOVE_OBJECT_16,OP_MOVE_RESULT,
         
        
        
         
          OP_MOVE_RESULT_WIDE,OP_MOVE_RESULT_OBJECT,
         
        
        
         
          OP_MOVE_EXCEPTION,OP_CONST_4,OP_CONST_16,OP_CONST,
         
        
        
         
          OP_CONST_HIGH16,OP_CONST_WIDE_16,OP_CONST_WIDE_32,
         
        
        
         
          OP_CONST_WIDE,OP_CONST_WIDE_HIGH16,OP_FILL_ARRAY_DATA,
         
        
        
         
          OP_CMPL_FLOAT,OP_CMPG_FLOAT,OP_CMPL_DOUBLE,
         
        
        
         
          OP_CMPG_DOUBLE,OP_CMP_LONG,OP_NEG_INT,OP_NOT_INT,
         
        
        
         
          OP_NEG_LONG,OP_NOT_LONG,OP_NEG_FLOAT,OP_NEG_DOUBLE,
         
        
        
         
          OP_INT_TO_LONG,OP_INT_TO_FLOAT,OP_INT_TO_DOUBLE,
         
        
        
         
          OP_LONG_TO_INT,OP_LONG_TO_FLOAT,OP_LONG_TO_DOUBLE,
         
        
        
         
          OP_FLOAT_TO_INT,OP_FLOAT_TO_LONG,OP_FLOAT_TO_DOUBLE,
         
        
        
         
          OP_DOUBLE_TO_INT,OP_DOUBLE_TO_LONG,OP_DOUBLE_TO_FLOAT,
         
        
        
         
          OP_INT_TO_BYTE,OP_INT_TO_CHAR,OP_INT_TO_SHORT,OP_ADD_INT,
         
        
        
         
          OP_SUB_INT,OP_MUL_INT,OP_AND_INT,OP_OR_INT,OP_XOR_INT,
         
        
        
         
          OP_SHL_INT,OP_SHR_INT,OP_USHR_INT,OP_ADD_LONG,OP_SUB_LONG,
         
        
        
         
          OP_MUL_LONG,OP_AND_LONG,OP_OR_LONG,OP_XOR_LONG,
         
        
        
         
          OP_SHL_LONG,OP_SHR_LONG,OP_USHR_LONG,OP_ADD_FLOAT,
         
        
        
         
          OP_SUB_FLOAT,OP_MUL_FLOAT,OP_DIV_FLOAT,OP_REM_FLOAT
         
        
        
         
          ,OP_ADD_DOUBLE,OP_SUB_DOUBLE,OP_MUL_DOUBLE,OP_DIV_DOUBLE,
         
        
        
         
          OP_REM_DOUBLE,OP_ADD_INT_2ADDR,OP_SUB_INT_2ADDR,
         
        
        
         
          OP_MUL_INT_2ADDR,OP_AND_INT_2ADDR,OP_OR_INT_2ADDR,
         
        
        
         
          OP_XOR_INT_2ADDR,OP_SHL_INT_2ADDR,OP_SHR_INT_2ADDR,
         
        
        
         
          OP_USHR_INT_2ADDR,OP_ADD_LONG_2ADDR,OP_SUB_LONG_2ADDR,
         
        
        
         
          OP_MUL_LONG_2ADDR,OP_AND_LONG_2ADDR,OP_OR_LONG_2ADDR,
         
        
        
         
          OP_XOR_LONG_2ADDR,OP_SHL_LONG_2ADDR,OP_SHR_LONG_2ADDR,
         
        
        
         
          OP_USHR_LONG_2ADDR,OP_ADD_FLOAT_2ADDR,OP_SUB_FLOAT_2ADDR,
         
        
        
         
          OP_MUL_FLOAT_2ADDR,OP_DIV_FLOAT_2ADDR,OP_REM_FLOAT_2ADDR,
         
        
        
         
          OP_ADD_DOUBLE_2ADDR,OP_SUB_DOUBLE_2ADDR,
         
        
        
         
          OP_MUL_DOUBLE_2ADDR,OP_DIV_DOUBLE_2ADDR,
         
        
        
         
          OP_REM_DOUBLE_2ADDR,OP_ADD_INT_LIT16,OP_RSUB_INT,
         
        
        
         
          OP_MUL_INT_LIT16,OP_AND_INT_LIT16,OP_OR_INT_LIT16,
         
        
        
         
          OP_XOR_INT_LIT16,OP_ADD_INT_LIT8,OP_RSUB_INT_LIT8,
         
        
        
         
          OP_MUL_INT_LIT8,OP_AND_INT_LIT8,OP_OR_INT_LIT8,OP_XOR_INT_LIT8,
         
        
        
         
          OP_SHL_INT_LIT8,OP_SHR_INT_LIT8,OP_USHR_INT_LIT8
          
          
         
        
       
       
        
         
          flags = kInstrCanContinue;
          
          
         
        
        
         
          表示這類指令會加入
         
         
          Trace
         
         
          區塊
         
         
          ,
         
         
          並不會造成
         
         
          Exception
         
        
       
      
      
       
        
         
          OP_CONST_STRING,OP_CONST_STRING_JUMBO,OP_CONST_CLASS,
         
        
        
         
          OP_MONITOR_ENTER,OP_MONITOR_EXIT,OP_CHECK_CAST,
         
        
        
         
          OP_INSTANCE_OF,OP_ARRAY_LENGTH,OP_NEW_INSTANCE,
         
        
        
         
          OP_NEW_ARRAY,OP_FILLED_NEW_ARRAY,OP_FILLED_NEW_ARRAY_RANGE
         
        
        
         
          ,OP_AGET,OP_AGET_BOOLEAN,OP_AGET_BYTE,OP_AGET_CHAR,
         
        
        
         
          OP_AGET_SHORT,OP_AGET_WIDE,OP_AGET_OBJECT,OP_APUT,
         
        
        
         
          OP_APUT_BOOLEAN,OP_APUT_BYTE,OP_APUT_CHAR,OP_APUT_SHORT,
         
        
        
         
          OP_APUT_WIDE,OP_APUT_OBJECT,OP_IGET,OP_IGET_BOOLEAN,
         
        
        
         
          OP_IGET_BYTE,OP_IGET_CHAR,OP_IGET_SHORT,OP_IGET_WIDE,
         
        
        
         
          OP_IGET_OBJECT,OP_IPUT,OP_IPUT_BOOLEAN,OP_IPUT_BYTE,
         
        
        
         
          OP_IPUT_CHAR,OP_IPUT_SHORT,OP_IPUT_WIDE,OP_IPUT_OBJECT,
         
        
        
         
          OP_SGET,OP_SGET_BOOLEAN,OP_SGET_BYTE,OP_SGET_CHAR,
         
        
        
         
          OP_SGET_SHORT,OP_SGET_WIDE,OP_SGET_OBJECT,OP_SPUT,
         
        
        
         
          OP_SPUT_BOOLEAN,OP_SPUT_BYTE,OP_SPUT_CHAR,OP_SPUT_SHORT,
         
        
        
         
          OP_SPUT_WIDE,OP_SPUT_OBJECT,OP_DIV_INT,OP_REM_INT,
         
        
        
         
          OP_DIV_LONG,OP_REM_LONG,OP_DIV_INT_2ADDR,OP_REM_INT_2ADDR,
         
        
        
         
          OP_DIV_LONG_2ADDR,OP_REM_LONG_2ADDR,OP_DIV_INT_LIT16,
         
        
        
         
          OP_REM_INT_LIT16,OP_DIV_INT_LIT8,OP_REM_INT_LIT8,
         
        
        
         
          OP_EXECUTE_INLINE,OP_EXECUTE_INLINE_RANGE,OP_IGET_QUICK,
         
        
        
         
          OP_IGET_WIDE_QUICK,OP_IGET_OBJECT_QUICK,OP_IPUT_QUICK,
         
        
        
         
          OP_IPUT_WIDE_QUICK,OP_IPUT_OBJECT_QUICK
          
          
         
        
       
       
        
         
          flags = kInstrCanContinue | kInstrCanThrow;
         
        
        
         
          表示這類指令會加入
         
         
          Trace
         
         
          區塊
         
         
          ,
         
         
          但有可能造成
         
         
          Exception
         
        
        
         
         
        
        
         
         
        
        
         
         
        
       
      
      
       
        
         
          OP_INVOKE_VIRTUAL,OP_INVOKE_VIRTUAL_RANGE,OP_INVOKE_SUPER,
         
        
        
         
          OP_INVOKE_SUPER_RANGE,OP_INVOKE_DIRECT,
         
        
        
         
          OP_INVOKE_DIRECT_RANGE,OP_INVOKE_STATIC,
         
        
        
         
          OP_INVOKE_STATIC_RANGE,OP_INVOKE_INTERFACE,
         
        
        
         
          OP_INVOKE_INTERFACE_RANGE,OP_INVOKE_VIRTUAL_QUICK,
         
        
        
         
          OP_INVOKE_VIRTUAL_QUICK_RANGE,OP_INVOKE_SUPER_QUICK,
         
        
        
         
          OP_INVOKE_SUPER_QUICK_RANGE,OP_INVOKE_DIRECT_EMPTY
         
        
       
       
        
         
          flags = kInstrCanContinue | kInstrCanThrow | kInstrInvoke;
          
          
         
        
        
         
          表示這類指令會加入
         
         
          Trace
         
         
          區塊
         
         
          ,
         
         
          有機會發生
         
         
          Exception
         
         
          或是進行外部呼叫
         
        
       
      
      
       
        
         
          OP_RETURN_VOID,OP_RETURN,OP_RETURN_WIDE,OP_RETURN_OBJECT
         
        
       
       
        
         
          flags = kInstrCanReturn;
         
        
        
         
          表示為
         
         
          Return
         
         
          指令
         
        
       
      
      
       
        
         
          OP_THROW,OP_THROW_VERIFICATION_ERROR
         
        
       
       
        
         
          flags = kInstrCanThrow;
         
        
        
         
          會觸發
         
         
          Exception
         
        
       
      
      
       
        
         
          OP_GOTO,OP_GOTO_16,OP_GOTO_32
         
        
       
       
        
         
          flags = kInstrCanBranch | kInstrUnconditional;
         
        
        
         
          表示一個無條件的
         
         
          Branch
         
         
          動作
         
        
       
      
      
       
        
         
          OP_IF_EQ,OP_IF_NE,OP_IF_LT,OP_IF_GE,OP_IF_GT,OP_IF_LE,OP_IF_EQZ,
         
        
        
         
          OP_IF_NEZ,OP_IF_LTZ,OP_IF_GEZ,OP_IF_GTZ,OP_IF_LEZ
          
          
         
        
       
       
        
         
          flags = kInstrCanBranch | kInstrCanContinue;
         
        
        
         
          表示一個搭配條件判斷的
         
         
          Branch
         
         
          動作
         
        
       
      
      
       
        
         
          OP_PACKED_SWITCH,OP_SPARSE_SWITCH
         
        
       
       
        
         
          flags = kInstrCanSwitch | kInstrCanContinue;
         
        
        
         
          表示一個
         
         
          Switch
         
         
          判斷
         
         
          ,
         
         
          如果該值不在這
         
         
          Switch
         
         
          中
         
         
          ,
         
         
          會加入
         
         
          Trace
         
         
          區塊
         
        
       
      
      
       
        
         
          OP_UNUSED_3E,OP_UNUSED_3F,OP_UNUSED_40,OP_UNUSED_41,
         
        
        
         
          OP_UNUSED_42,OP_UNUSED_43,OP_UNUSED_73,OP_UNUSED_79,
         
        
        
         
          OP_UNUSED_7A,OP_UNUSED_E3,OP_UNUSED_E4,OP_UNUSED_E5,
         
        
        
         
          OP_UNUSED_E6,OP_UNUSED_E7,OP_UNUSED_E8,OP_UNUSED_E9,
         
        
        
         
          OP_UNUSED_EA,OP_UNUSED_EB,OP_BREAKPOINT,OP_UNUSED_F1,
         
        
        
         
          OP_UNUSED_FC,OP_UNUSED_FD,OP_UNUSED_FE,OP_UNUSED_FF
         
        
       
       
        
         
          these should never appear when scanning code
         
        
        
         
          flags=0
         
        
       
      
     
    
    
     
     
    
    
     
      
      
     
     
      後續
     
     
      ,
     
     
      呼叫
     
     
      dexGetInstrOrTableWidthAbs(
     
     
      實作在
     
     
      libdex/InstrUtils.c)
     
     
      判斷所在位置指令或是資料
     
     
      (PackedSwitchSignature/SparseSwitchSignature/ArrayDataSignature)
     
     
      的長度
     
     
      (
     
     
      指令長度的
     
     
      Table
     
     
      可以透過函式
     
     
      dexCreateInstrWidthTable
     
     
      建立
     
     
      ),
     
     
      以及距離所在
     
     
      Class Method
     
     
      起始點的位置
     
     
      (lastPC – interpState->;method->;insns),
     
     
      如果超過該
     
     
      Class Method
     
     
      的實際實作的大小
     
     
      ,
     
     
      就會觸發
     
     
      Assertion.
     
    
    
     
      
      
     
    
    
     
      
      
     
     
      等到完成一個
     
     
      Trace
     
     
      流程段落
     
     
      ,
     
     
      會呼叫函式
     
     
      dvmCompilerWorkEnqueue,
     
     
      把這個
     
     
      Trace
     
     
      流程段落放到
     
     
      JIT
     
     
      編譯器的
     
     
      Queue
     
     
      中
     
     
      ,
     
     
      之後就會由
     
     
      Compiler
     
     
      的
     
     
      thread
     
     
      透過函式
     
     
      dvmCompileTrace(
     
     
      實作在
     
     
      dalvik/vm/compiler/Frontend.c)
     
     
      進行編譯為原生碼的動作
     
     
      .
     
     
      並重新回到函式
     
     
      dvmMterpStd,
     
     
      繼續下一個指令集的抓取與執行
     
     
      ,
     
     
      直到又有指令
     
     
      Threshold
     
     
      被滿足
     
     
      ,
     
     
      而進行下一次的
     
     
      Trace
     
     
      追蹤的流程
     
     
      .
     
     
      在進行
     
     
      Trace
     
     
      追蹤的流程時
     
     
      ,
     
     
      相關指令都還是會以
     
     
      Fast Interpreter
     
     
      的實作被執行
     
     
      .
      
      
     
    
    
     
     
    
    
     
      
      
     
     
      要在
     
     
     
     
      Android
     
     
      環境中支援
     
     
      JIT
     
     
      機制
     
     
      ,
     
     
      必須在
     
     
      Dalvik
     
     
      編譯時加入
     
     
      WITH_JIT
     
     
      參數
     
     
      ,
     
     
      可以參考
     
     
      dalvik/vm/Android.mk,
     
     
      如果所選擇的架構是
     
     
      armv5te (TARGET_ARCH_VARIANT:=armv5te),WITH_JIT
     
     
      預設會是關掉的
     
     
      .
     
     
      然後修改
     
     
      build/target/board/generic/system.prop
     
     
      加入
     
     
      dalvik.vm.execution-mode=int:jit (
     
     
      這個系統參數設定會被加入到執行時期的檔案
     
     
      /system/build.prop),
     
     
      ,
     
     
      就可以開始編譯支援
     
     
      Dalvik JIT
     
     
      的虛擬器
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      支援
     
     
      JIT
     
     
      的
     
     
      Dalvik
     
     
      環境除了會編譯出
     
     
     
     
      libdvm.so
     
     
      外
     
     
      ,
     
     
      參考
     
     
      dalvik/vm/Android.mk,
     
     
      在編譯
     
     
      Dalvik
     
     
      函式庫時
     
     
      ,
     
     
      還會額外產生以下三個函式庫
     
    
    
     
      
      
      libdvm_sv.so (
     
     
      開啟
     
     
      Assertion
     
     
      與
     
     
      self-verification)
     
    
    
     
      
      
      libdvm_assert.so (
     
     
      開啟
     
     
      Assertion
     
     
      與
     
     
      JIT Tuning)
     
    
    
     
      
      
      libdvm_interp.so (
     
     
      這是把
     
     
      WITH_JIT
     
     
      關閉的版本
     
     
      )
     
    
    
     
     
    
    
     
      
      
     
     
      可根據自己開發上的除錯
     
     
      ,
     
     
      決定要採用的版本
     
     
      .
     
    
    
     
     
    
    
     
      
      
     
     
      要確認所編譯的
     
     
      Dalvik
     
     
      虛擬器有無啟動
     
     
      JIT
     
     
      機制
     
     
      ,
     
     
      可以在啟動後
     
     
      ,
     
     
      執行
     
     
      dalvikvm -h
     
     
      查看是否有下列參數設定
     
    
    
     
     
    
    
     
      
      
      -Xjitop:hexopvalue[-endvalue][,hexopvalue[-endvalue]]*
     
    
    
     
      
      
      -Xincludeselectedmethod
     
    
    
     
      
      
      -Xjitthreshold:decimalvalue
     
    
    
     
      
      
      -Xjitblocking
     
    
    
     
      
      
      -Xjitmethod:signature[,signature]* (eg Ljava/lang/String/;replace)
     
    
    
     
      
      
      -Xjitcheckcg
     
    
    
     
      
      
      -Xjitverbose
     
    
    
     
      
      
      -Xjitprofile
     
    
    
     
      
      
      -Xjitdisableopt
      
      
     
    
    
     
     
    
    
     
     
    
    
     
      
       簡述
      
     
     
      
       ADB,Emulator
      
     
     
      
       與
      
     
     
      
       NDK-GDB
      
     
     
      
       運作的機制
      
     
     
     
    
    
     
     
    
    
     
      
      
     
     
      在非直接使用實體手機裝置透過
     
     
      USB
     
     
      開發的環境下
     
     
      ,
     
     
      我們可以透過電腦上的模擬器達到便利開發的目的
     
     
      ,
     
     
      根據上述的流程
     
     
      ,
     
     
      我們可以看到包括
     
     
      abd
     
     
      或是
     
     
      ndk-gdb
     
     
      這些輔助開發
     
     
      ,
     
     
      安裝與除錯的工具
     
     
      ,
     
     
      都可以跟
     
     
      Emulator
     
     
      互通
     
     
      .
     
     
      目前
     
     
      ADB,Emulator
     
     
      或是
     
     
      NDK-GDB
     
     
      都是透過網路
     
     
      TCP
     
     
      連線的方式進行互通
     
     
      .
     
     
      如果使用者使用
     
     
      Eclipse
     
     
      加上
     
     
      ADT
     
     
      的環境
     
     
      ,
     
     
      一開始會產生一個
     
     
      ADB
     
     
      的
     
     
      Daemon,
     
     
      監聽
     
     
      port 5037,
     
     
      而
     
     
      Eclipse
     
     
      上的
     
     
      ADT
     
     
      套件
     
     
      ,
     
     
      會產生連線到
     
     
      ADT
     
     
      的
     
     
      port 5037.
     
     
      如果有執行
     
     
      Emulator
     
     
      的話
     
     
      ,
     
     
      就會由
     
     
      ADT
     
     
      連到
     
     
      Emulator
     
     
      所監聽的
     
     
      Port5555,
     
     
      與
     
     
      Eclipse
     
     
      連到
     
     
      Emulator
     
     
      所監聽的
     
     
      Port 5554. Emulator
     
     
      的
     
     
      Port
     
     
      訊息也會透過
     
     
      ADB Port 5037
     
     
      交換
     
     
      ,
     
     
      如下所示
     
    
    
     
     
    
    
     
      Receive Side Port:5037
     
    
    
     
      ==>;Return Code: 0x00000000
     
    
    
     
      
      
      001Chost:transport:emulator-5554
     
    
    
     
     
    
    
     
      Send Size Port:40280
     
    
    
     
      ==>; Return Code: 0x00000000
     
    
    
     
      
      
      OKAY
     
    
    
     
     
    
    
     
      
      
     
     
      如果使用者透過
     
     
      ndk-gdb - -start
     
     
      啟動對
     
     
     
     
      JNI
     
     
      應用除錯機制的話
     
     
      ,
     
     
      就會由
     
     
      arm-linux-androideabi-gdb.
     
     
      連到
     
     
      adb
     
     
      所監聽的
     
     
      Port 5039
     
     
      進行
     
     
      GDB
     
     
      的操作動作
     
     
      .
     
    
    
     
     
    
    
     
     
    
    
     
      (Receive Port:5037 Send Port:49288)
     
    
    
     
      Receive: Return Code: 0x00000000
     
    
    
     
      0052host:forward:tcp:5039;localfilesystem:/data/data/com.example.hellojni/debug-socket
     
    
    
     
     
    
    
     
      Send: Return Code: 0x00000000
     
    
    
     
      OKAYOKAY
     
    
    
     
     
    
    
     
     
    
    
     
      (Receive Port:5037 Send Port:49290)
     
    
    
     
     
    
    
     
      Receive: Return Code: 0x00000000
     
    
    
     
      0012host:transport-any
     
    
    
     
     
    
    
     
      Send: Return Code: 0x00000000
     
    
    
     
      OKAY
     
    
    
     
     
    
    
     
      Receive: Return Code: 0x00000000
     
    
    
     
      004ashell:run-as com.example.hellojni lib/gdbserver +debug-socket --attach 348
     
    
    
     
     
    
    
     
      Send: Return Code: 0x00000000
     
    
    
     
      OKAY
     
    
    
     
     
    
    
     
      Send: Return Code: 0x00000000
     
    
    
     
      Attached; pid = 348
     
    
    
     
     
    
    
     
     
    
    
     
      Send: Return Code: 0x00000000
     
    
    
     
      Listening on sockaddr socket debug-socket
     
    
    
     
     
    
    
     
      (Receive Port:5039 Send Port:49295)
     
    
    
     
      Receive: Return Code: 0x00000000
     
    
    
     
      $qSupported#37
     
    
    
     
     
    
    
     
      Send: Return Code: 0x00000000
     
    
    
     
      +$PacketSize=7cf;qXfer:auxv:read+#70
     
    
    
     
     
    
    
     
      Receive: Return Code: 0x00000000
     
    
    
     
      ++$Hc-1#09
     
    
    
     
     
    
    
     
      Send: Return Code: 0x00000000
     
    
    
     
      +$E01#a6
     
    
    
     
     
    
    
     
      Receive: Return Code: 0x00000000
     
    
    
     
      +$qC#b4
     
    
    
     
     
    
    
     
      Send: Return Code: 0x00000000
     
    
    
     
      +$#00
     
    
    
     
     
    
    
     
      Receive: Return Code: 0x00000000
     
    
    
     
      +$qOffsets#4b
     
    
    
     
     
    
    
     
      Send: Return Code: 0x00000000
     
    
    
     
      +$#00
     
    
    
     
     
    
    
     
      Receive: Return Code: 0x00000000
     
    
    
     
      +$?#3f
     
    
    
     
     
    
    
     
      Send: Return Code: 0x00000000
     
    
    
     
      +$T050b:0*"00;0d:9838a0be;0f:08ebd0af;#6e
     
    
    
     
     
    
    
     
      Receive: Return Code: 0x00000000
     
    
    
     
      +$m9040,108#ff
     
    
    
     
     
    
    
     
      Send: Return Code: 0x00000000
     
    
    
     
      +$010*"c4ca00b0010*"24cf00b0010*"3cd000b0010*"6cd200b0010*"84d300b0010*"dccb00b0010*"f4cc00b0010*"0cce00b020*%90*!210*"080*"190*"0890*!1b0*"080*"1a0*"1090*!1c0*"080*"040*"08810*!50*"ec840*!60*"4c820*!a0*"e5030*!b0*"10*"0150*"a8c400b0030*"48910*!20*"b0*"0140*"110*"170*"fc880* 110*"d4880* 120*"280*"130*"080*}0*!#a8
     
    
    
     
     
    
    
     
      Receive: Return Code: 0x00000000
     
    
    
     
      +$mb000c4ac,4#1a
     
    
    
     
     
    
    
     
      Send: Return Code: 0x00000000
     
    
    
     
      +$b0ca00b0#48
     
    
    
     
     
    
    
     
      Receive: Return Code: 0x00000000
     
    
    
     
      +$mb000cab0,14#46
     
    
    
     
     
    
    
     
      Send: Return Code: 0x00000000
     
    
    
     
      +$0*"00db3da0be0*"00e04901b0*%#b1
     
    
    
     
     
    
    
     
      Receive: Return Code: 0x00000000
     
    
    
     
      +$mb00149e0,14#f3
     
    
    
     
     
    
    
     
      Send: Return Code: 0x00000000
     
    
    
     
      +$0*"00dc4801b0*%e0cc00b0b0ca00b0#e6
     
    
    
     
     
    
    
     
     
    
   
  
 


