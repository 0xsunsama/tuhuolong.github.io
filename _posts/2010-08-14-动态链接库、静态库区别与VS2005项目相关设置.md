---
layout: post
title: 动态链接库、静态库区别与VS2005项目相关设置
date: 2010-08-14 19:55:00
categories: [C++]
tags: [编译器, dll, windows, library, compiler, import]
---
出处：[http://blog.csdn.net/Ocean2006/archive/2010/02/05/5289908.aspx](http://blog.csdn.net/Ocean2006/archive/2010/02/05/5289908.aspx)
 
     一、动态链接库、静态库区别
     二、VS2005项目相关设置
     三、#pragma预处理指令
 
**动态链接库、静态库区别**
      1、动态链接库(Dynamic Linked Library)
      Windows系统平台上你可以将独立的程序模块创建为较小的DLL(Dynamic Linkable Library)文件，并可对它们单独编译和测试。在运行时，只有当EXE程序确实要调用这些DLL模块的情况下，系统才会将它们装载到内存空间中。这种方式不仅减少了EXE文件的大小和对内存空间的需求，而且使这些DLL模块可以同时被多个应用程序使用。Windows自己就将一些主要的系统功能以DLL模块的形式实现。Windows为应用程序提供了丰富的函数调用，这些函数调用都包含在动态链接库中。其中有3个最重要的DLL，Kernel32.dll，它包含用于管理内存、进程和线程的各个函数；User32.dll，它包含用于执行用户界面任务(如窗口的创建和消息的传送)的各个函数；GDI32.dll，它包含用于画图和显示文本的各个函数。
      在使用动态链接库的时候，往往提供两个文件：一个引入库(Import Library)和一个DLL。引入库包含被DLL导出的函数和变量的符号名，DLL包含实际的函数和数据。在编译链接可执行文件时，只需要链接引入库，DLL中的函数代码和数据并不复制到可执行文件中，在运行的时候，再去加载DLL，访问DLL中导出的函数。 一个Windows的.EXE文件拥有它使用不同动态链接库的引用，所使用的函数即在那里。当Windows程序被加载到内存中时，程序中的调用被指向DLL函数的入口，如果DLL不在内存中，系统就将其加载到内存中。当链接Windows程序以产生一个可执行文件时，你必须链接由编程环境提供的专门的“导入库(import library)库”。这些导入库包含了动态链接库名称和所有Windows函数调用的引用信息。链接程序使用该信息在.EXE文件中构造一个表，当加载程序时，Windows使用它将调用转换为Windows函数。
      2、静态库(Static Library)
      函数和数据被编译进一个二进制文件(通常扩展名为.LIB)。在使用静态库的情况下，在编译链接可执行文件时，链接器从库中复制这些函数和数据并把它们和应用程序的其它模块组合起来创建最终的可执行文件(.EXE文件)。
      导入库和静态库的区别很大，他们实质是不一样的东西。静态库本身就包含了实际执行代码、符号表等等，而对于导入库而言，其实际的执行代码位于动态库中，导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息。
      静态链接与动态链接：
      静态链接方法：#pragma comment(lib, “test.lib”) ，静态链接的时候，载入代码就会把程序会用到的动态代码或动态代码的地址确定下来静态库的链接可以使用静态链接，动态链接库也可以使用这种方法链接导入库
      动态链接方法：LoadLibrary()/GetProcessAddress()和FreeLibrary()，使用这种方式的程序并不在一开始就完成动态链接，而是直到真正调用动态库代码时，载入程序才计算(被调用的那部分)动态代码的逻辑地址，然后等到某个时候，程序又需要调用另外某块动态代码时，载入程序又去计算这部分代码的逻辑地址，所以，这种方式使程序初始化时间较短，但运行期间的性能比不上静态链接的程序。
 
**VS2005项目相关设置**
      应用程序使用外部库时需要进行加载，两种库的加载本质上都是一样：提供功能和功能的定义！vs2005 c++ 项目设置外部库方法如下：
     1. 添加编译所需要（依赖）的 lib 文件
         在“项目->属性->配置属性->连接器->输入->附加依赖项”里填写“winsock.lib”，多个 lib 以空格隔开，等同于“#pragma   
         comment(lib, “*.lib”) ”语句。
     2. 添加库（libs）文件目录
         方法 1：项目->属性->配置属性->连接器->常规->附加库目录”
         方法 2：[菜单]“工具->选项->项目和解决方案->c++ 目录”，选择对应平台，然后添加所需“库文件”目录
         这个设置类似于设置环境变量，主要是为程序设置搜索的库目录，真正进行库加载还需要进行第一种设置！
     3. 添加包含（include）文件目录
         方法 1：“项目->属性->配置属性->c/c++->常规->附加包含目录”
         方法 2：[菜单]“工具->选项->项目和解决方案->c++ 目录”，添加所需“包括文件”目录
         方法2类似于设置环境变量。
     4. 导入库（import）
         在“项目->属性->配置属性->连接器->高级->导入库”填写需要生成的导入库
 
 

**#pragma预处理指令**
     在所有的预处理指令中，#pragma指令可能是最复杂的了，它的作用是设定编译器的状态或者是指示编译器完成一些特定的动作。#pragma指令对每个编译器给出了一个方法,在保持与C和C++语言完全兼容的情况下,给出主机或操作系统专有的特征。依据定义,编译指示是机器或操作系统专有的,且对于每个编译器都是不同的。
　　其格式一般为: #Pragma Para
　　其中Para 为参数，下面来看一些常用的参数。
　　1、message 参数。 Message 参数能够在编译信息输出窗口中输出相应的信息，这对于源代码信息的控制是非常重要的。其使用方法为：
　　#Pragma message(“消息文本”)
　　当编译器遇到这条指令时就在编译输出窗口中将消息文本打印出来。
　　2、另一个使用得比较多的pragma参数是code_seg。格式如：
　　#pragma code_seg( ["section-name"[,"section-class"] ] )
　　它能够设置程序中函数代码存放的代码段，当我们开发驱动程序的时候就会使用到它。
　　3、#pragma once (比较常用）
　　只要在头文件的最开始加入这条指令就能够保证头文件被编译一次，这条指令实际上在VC6中就已经有了，但是考虑到兼容性并没有太多的使用它。
　　#pragma once是编译相关，就是说这个编译系统上能用，但在其他编译系统不一定可以，也就是说移植性差，不过现在基本上已经是每个编译器都有这个定义了。
　　4、#pragma warning( disable : 4507 34; once : 4385; error : 164 )
　　等价于：
　　#pragma warning(disable:4507 34) // 不显示4507和34号警告信息
　　#pragma warning(once:4385) // 4385号警告信息仅报告一次
　　#pragma warning(error:164) // 把164号警告信息作为一个错误。
　　同时这个pragma warning 也支持如下格式：
　　#pragma warning( push [ ,n ] )
　　#pragma warning( pop )
　　这里n代表一个警告等级(1—4)。
　　#pragma warning( push )保存所有警告信息的现有的警告状态。
　　#pragma warning( push, n)保存所有警告信息的现有的警告状态，并且把全局警告等级设定为n。
　　#pragma warning( pop )向栈中弹出最后一个警告信息，
　　在入栈和出栈之间所作的一切改动取消。例如：
　　#pragma warning( push )
　　#pragma warning( disable : 4705 )
　　#pragma warning( disable : 4706 )
　　#pragma warning( disable : 4707 )
　　//…….
　　#pragma warning( pop )
　　在这段代码的最后，重新保存所有的警告信息(包括4705，4706和4707)。
　　5、#pragma comment(…)
　　该指令将一个注释记录放入一个对象文件或可执行文件中，常用的lib关键字，可以帮我们连入一个库文件。该指令的格式为
          #pragma comment( “comment-type” [, commentstring] )
      该指令将一个注释记录放入一个对象文件或可执行文件中，comment-type(注释类型):可以指定为五种预定义的标识符的其中一种五种预定义的标识符为:
      compiler:将编译器的版本号和名称放入目标文件中,本条注释记录将被编译器忽略，如果你为该记录类型提供了commentstring参数,编译器将会产生一个警告，例如:#pragma comment( compiler )。
      exestr:将commentstring参数放入目标文件中,在链接的时候这个字符串将被放入到可执行文件中,当操作系统加载可执行文件的时候,该参数字符串不会被加载到内存中.但是,该字符串可以被dumpbin之类的程序查找出并打印出来,你可以用这个标识符将版本号码之类的信息嵌入到可执行文件中。
      lib:这是一个非常常用的关键字，用来将一个库文件链接到目标文件中常用的lib关键字，可以帮我们连入一个库文件。例如:
          #pragma comment(lib, “user32.lib”)， 该指令用来将user32.lib库文件加入到本工程中。
      linker:将一个链接选项放入目标文件中,你可以使用这个指令来代替由命令行传入的或者在开发环境中设置的链接选项,你可以设定/include选项来强制包含某个对象。
[](http://blog.csdn.net/Ocean2006/archive/2010/02/05/5289908.aspx)
