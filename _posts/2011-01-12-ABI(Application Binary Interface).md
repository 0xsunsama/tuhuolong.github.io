---
layout: post
title: ABI(Application Binary Interface)
date: 2011-01-12 15:00:00
categories: [C++]
tags: [application, interface, api, compiler, 平台, linux]
---
ABI
是系统与应用之间的协议. 一个BINARY(EXEC, LIB)必需符合ABI才能在相应的系统上运行.
比如我在PC上用不管什么样的COMPILER, 只要产生符合LINUX的ELF文件, 用相应的INSTRUCTION SET(比如INTEL, 
PPC, SPARC). 就可以在一个LINUX机器上运行. 调用系统或别人的LIB.
ABI定义了BINARY的文件格式, 内容, 以及装载/卸载程序的要求, 函数调用的参数传递规则, 寄存器, 堆栈的使用等. 
      abi（应用二进制接口）我的理解就是机器代码一层的接口。先说一下api（特指系统调用）,
api基本上是和机器硬件平台无关但是和操作系统密切相关的接口，一个api调用定义了一个对内核的操作，以及操作的参数。C语言会议函数的形式调用
api。
   
     abi，是比api更贴近硬件的一层接口，它规定的是二进制代码之间的调用规则。举个例子来说吧！
一个应用程序，调用了.so库中的函数或者系统调用，如果它的编译器可以找到被调用函数或者系统
调用的话，则编译可以同过，也就是说，它是用的api是正确的。但是，这个调用离成功还很远。。。。。
   
     首先，如果编译出来的代码和运行库函数和系统调用的代码不是一个硬件平台的，则这个应用根本就不能和被调用代码运行在一起，则调用不会成功。
   
     
即使库函数、系统调用和是运行在同一硬件平台上的调用也不一定会趁成功。因为程序最终是被编译成二进制代码的，并且是要加载到内存中运行的。那么，在调用
库函数或者系统调用的时候，应用要先要以库函数或者系统调用指定的方式和位置（内存或者寄存器）设置参数，然后通过中断或者其他方式跳转到被调用代码的起
始处进行执行，被调用代码从指定位置去到参数，处理完毕之后再将结果放到指定的位置，最后应用再到指定的地方取回结果，调用完毕！
     
我认为这个过程中，存放参数和结果的位置属于abi规定的范围，被调用程序的跳转地址或者中断号码也是abi规定的范围。如果存取参数、结果的位置没有明
确的规范，或者调用、被调用双方没有遵照统一个规范，那么这个调用能够根本就不可能成功；如果系统提供的库函数路径不正确，调用也不会成功；如果中断代码
使用错误，调用也不会正确。abi 就是在这个层次上对应用程序的一个规范。
