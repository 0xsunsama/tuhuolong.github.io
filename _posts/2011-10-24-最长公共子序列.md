---
layout: post
title: 最长公共子序列
date: 2011-10-24 09:41:00
categories: [算法]
tags: [算法, 优化, n2]
---
动态规划的一个计算最长公共子序列的方法如下：
以两个序列 X、Y 为例子：
设有二维数组 f[i][j] 表示 X 的 i 位和 Y 的 j 位之前的最长公共子序列的长度，则有：
 
      f[1][1] = same(1,1)
      f[i][j] = max{f[i-1][j-1]+same(i,j)，f[i-1][j]，f[i][j-1]}
 
    其中，same(a,b)当 X 的第 a 位与 Y 的第 b 位完全相同时为“1”，否则为“0”。
此时，f[i][j]中最大的数便是 X 和 Y 的最长公共子序列的长度，依据该数组回溯，便可找出最长公共子序列。
 
 该算法的空间、时间复杂度均为O(n2)，经过优化后，空间复杂度可为O(n)，时间复杂度为O(nlogn)