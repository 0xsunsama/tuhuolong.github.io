---
layout: post
title: 垃圾回收趣史
date: 2011-03-28 15:02:00
categories: [内存管理, Tuhuolong]
tags: [算法, lisp, 语言, allocation, 工作, java]
---
引用计数(循环引用,Stop-The-World)----JavaScript
     |
标记-清除(碎片,占CPU,Stop-The-World)
     | 
双区复制(浪费一半内存,Stop-The-World)
     |
标记-压缩(Stop-The-World)
     |
  增量:并发
     |
  分代----Java
  
  
写作本文的初衷是想和大家分享垃圾收集（ Garbage Collection ）技术简单而有趣的发
展史。动笔之前，我站在窗边，望了望正在小区里装运垃圾的清洁车。和生活中环卫工人
们清运垃圾的工作相似，软件开发里的垃圾收集其实就是一种自动打扫和清除内存垃圾的
技术，它可以有效防范动态内存分配中可能发生的两个危险：因内存垃圾过多而引发的内
存耗尽（这和生活垃圾堵塞排污管道的危险并没有什么本质的不同），以及不恰当的内存
释放所造成的内存非法引用（这类似于我们在生活中买到了一瓶已经过期三年的牛奶）。


据历史学家们介绍，四千多年前的古埃及人已经在城市里建设了完善的排污和垃圾清运设
施，一千多年前的中国人更是修筑了当时世界上保洁能力最强的都市 ——长安。今天，当
我们在软件开发中体验自动垃圾收集的便捷与舒适时，我们至少应当知道，这种拒绝杂乱
、追求整洁的“垃圾收集”精神其实是人类自古以来就已经具备了的。

拓荒时代

国内的程序员大多是在 Java 语言中第一次感受到垃圾收集技术的巨大魅力的，许多人也
因此把 Java 和垃圾收集看成了密不可分的整体。但事实上，垃圾收集技术早在 Java 语
言问世前 30 多年就已经发展和成熟起来了， Java 语言所做的不过是把这项神奇的技术
带到了广大程序员身边而已。

如果一定要为垃圾收集技术找一个孪生兄弟，那么， Lisp 语言才是当之无愧的人选。 1
960 年前后诞生于 MIT 的 Lisp 语言是第一种高度依赖于动态内存分配技术的语言： Li
sp 中几乎所有数据都以“表”的形式出现，而“表”所占用的空间则是在堆中动态分配得
到的。 Lisp 语言先天就具有的动态内存管理特性要求 Lisp 语言的设计者必须解决堆中
每一个内存块的自动释放问题（否则， Lisp 程序员就必然被程序中不计其数的 free 或
delete 语句淹没），这直接导致了垃圾收集技术的诞生和发展——说句题外话，上大学
时，一位老师曾告诉我们， Lisp 是对现代软件开发技术贡献最大的语言。我当时对这一
说法不以为然：布满了圆括号，看上去像迷宫一样的 Lisp 语言怎么能比 C 语言或 Pasc
al 语言更伟大呢？不过现在，当我知道垃圾收集技术、数据结构技术、人工智能技术、并
行处理技术、虚拟机技术、元数据技术以及程序员们耳熟能详的许多技术都起源于 Lisp
语言时，我特别想向那位老师当面道歉，并收回我当时的幼稚想法。

知道了 Lisp 语言与垃圾收集的密切关系，我们就不难理解，为什么垃圾收集技术的两位
先驱者 J. McCarthy 和 M. L. Minsky 同时也是 Lisp 语言发展史上的重要人物了。 J.
McCarthy 是 Lisp 之父，他在发明 Lisp 语言的同时也第一次完整地描述了垃圾收集的
算法和实现方式； M. L. Minsky 则在发展 Lisp 语言的过程中成为了今天好几种主流垃
圾收集算法的奠基人——和当时不少技术大师的经历相似， J. McCarthy 和 M. L. Mins
ky 在许多不同的技术领域里都取得了令人艳羡的成就。也许，在 1960 年代那个软件开发
史上的拓荒时代里，思维敏捷、意志坚定的研究者更容易成为无所不能的西部硬汉吧。


在了解垃圾收集算法的起源之前，有必要先回顾一下内存分配的主要方式。我们知道，大
多数主流的语言或运行环境都支持三种最基本的内存分配方式，它们分别是：

一、静态分配（ Static Allocation ）：静态变量和全局变量的分配形式。我们可以把静
态分配的内存看成是家里的耐用家具。通常，它们无需释放和回收，因为没人会天天把大
衣柜当作垃圾扔到窗外。

二、自动分配（ Automatic Allocation ）：在栈中为局部变量分配内存的方法。栈中的
内存可以随着代码块退出时的出栈操作被自动释放。这类似于到家中串门的访客，天色一
晚就要各回各家，除了个别不识时务者以外，我们一般没必要把客人捆在垃圾袋里扫地出
门。

三、动态分配（ Dynamic Allocation ）：在堆中动态分配内存空间以存储数据的方式。
堆中的内存块好像我们日常使用的餐巾纸，用过了就得扔到垃圾箱里，否则屋内就会满地
狼藉。像我这样的懒人做梦都想有一台家用机器人跟在身边打扫卫生。在软件开发中，如
果你懒得释放内存，那么你也需要一台类似的机器人——这其实就是一个由特定算法实现
的垃圾收集器。

也就是说，下面提到的所有垃圾收集算法都是在程序运行过程中收集并清理废旧“餐巾纸
”的算法，它们的操作对象既不是静态变量，也不是局部变量，而是堆中所有已分配内存
块。

引用计数（ Reference Counting ）算法


1960 年以前，人们为胚胎中的 Lisp 语言设计垃圾收集机制时，第一个想到的算法是引用
计数算法。拿餐巾纸的例子来说，这种算法的原理大致可以描述为：

午餐时，为了把脑子里突然跳出来的设计灵感记下来，我从餐巾纸袋中抽出一张餐巾纸，
打算在上面画出系统架构的蓝图。按照“餐巾纸使用规约之引用计数版”的要求，画图之
前，我必须先在餐巾纸的一角写上计数值 1 ，以表示我在使用这张餐巾纸。这时，如果你
也想看看我画的蓝图，那你就要把餐巾纸上的计数值加 1 ，将它改为 2 ，这表明目前有
2 个人在同时使用这张餐巾纸（当然，我是不会允许你用这张餐巾纸来擦鼻涕的）。你看
完后，必须把计数值减 1 ，表明你对该餐巾纸的使用已经结束。同样，当我将餐巾纸上的
内容全部誊写到笔记本上之后，我也会自觉地把餐巾纸上的计数值减 1 。此时，不出意外
的话，这张餐巾纸上的计数值应当是 0 ，它会被垃圾收集器——假设那是一个专门负责打
扫卫生的机器人——捡起来扔到垃圾箱里，因为垃圾收集器的惟一使命就是找到所有计数
值为 0 的餐巾纸并清理它们。

引用计数算法的优点和缺陷同样明显。这一算法在执行垃圾收集任务时速度较快，但算法
对程序中每一次内存分配和指针操作提出了额外的要求（增加或减少内存块的引用计数）
。更重要的是，引用计数算法无法正确释放循环引用的内存块，对此， D. Hillis 有一段
风趣而精辟的论述：

一天，一个学生走到 Moon 面前说：“我知道如何设计一个更好的垃圾收集器了。我们必
须记录指向每个结点的指针数目。” Moon 耐心地给这位学生讲了下面这个故事：“一天
，一个学生走到 Moon 面前说：‘我知道如何设计一个更好的垃圾收集器了……’”

D. Hillis 的故事和我们小时候常说的“从前有座山，山上有个庙，庙里有个老和尚”的
故事有异曲同工之妙。这说明，单是使用引用计数算法还不足以解决垃圾收集中的所有问
题。正因为如此，引用计数算法也常常被研究者们排除在狭义的垃圾收集算法之外。当然
，作为一种最简单、最直观的解决方案，引用计数算法本身具有其不可替代的优越性。 1
980 年代前后， D. P. Friedman ， D. S. Wise ， H. G. Baker 等人对引用计数算法进
行了数次改进，这些改进使得引用计数算法及其变种（如延迟计数算法等）在简单的环境
下，或是在一些综合了多种算法的现代垃圾收集系统中仍然可以一展身手。

标记－清除（ Mark-Sweep ）算法


第一种实用和完善的垃圾收集算法是 J. McCarthy 等人在 1960 年提出并成功地应用于
Lisp 语言的标记－清除算法。仍以餐巾纸为例，标记－清除算法的执行过程是这样的：


午餐过程中，餐厅里的所有人都根据自己的需要取用餐巾纸。当垃圾收集机器人想收集废
旧餐巾纸的时候，它会让所有用餐的人先停下来，然后，依次询问餐厅里的每一个人：“
你正在用餐巾纸吗？你用的是哪一张餐巾纸？”机器人根据每个人的回答将人们正在使用
的餐巾纸画上记号。询问过程结束后，机器人在餐厅里寻找所有散落在餐桌上且没有记号
的餐巾纸（这些显然都是用过的废旧餐巾纸），把它们统统扔到垃圾箱里。

正如其名称所暗示的那样，标记－清除算法的执行过程分为“标记”和“清除”两大阶段
。这种分步执行的思路奠定了现代垃圾收集算法的思想基础。与引用计数算法不同的是，
标记－清除算法不需要运行环境监测每一次内存分配和指针操作，而只要在“标记”阶段
中跟踪每一个指针变量的指向——用类似思路实现的垃圾收集器也常被后人统称为跟踪收
集器（ Tracing Collector ）

伴随着 Lisp 语言的成功，标记－清除算法也在大多数早期的 Lisp 运行环境中大放异彩
。尽管最初版本的标记－清除算法在今天看来还存在效率不高（标记和清除是两个相当耗
时的过程）等诸多缺陷，但在后面的讨论中，我们可以看到，几乎所有现代垃圾收集算法
都是标记－清除思想的延续，仅此一点， J. McCarthy 等人在垃圾收集技术方面的贡献就
丝毫不亚于他们在 Lisp 语言上的成就了。

复制（ Copying ）算法


为了解决标记－清除算法在垃圾收集效率方面的缺陷， M. L. Minsky 于 1963 年发表了
著名的论文“一种使用双存储区的 Lisp 语言垃圾收集器（ A LISP Garbage Collector
Algorithm Using Serial Secondary Storage ）”。 M. L. Minsky 在该论文中描述的算
法被人们称为复制算法，它也被 M. L. Minsky 本人成功地引入到了 Lisp 语言的一个实
现版本中。

复制算法别出心裁地将堆空间一分为二，并使用简单的复制操作来完成垃圾收集工作，这
个思路相当有趣。借用餐巾纸的比喻，我们可以这样理解 M. L. Minsky 的复制算法：


餐厅被垃圾收集机器人分成南区和北区两个大小完全相同的部分。午餐时，所有人都先在
南区用餐（因为空间有限，用餐人数自然也将减少一半），用餐时可以随意使用餐巾纸。
当垃圾收集机器人认为有必要回收废旧餐巾纸时，它会要求所有用餐者以最快的速度从南
区转移到北区，同时随身携带自己正在使用的餐巾纸。等所有人都转移到北区之后，垃圾
收集机器人只要简单地把南区中所有散落的餐巾纸扔进垃圾箱就算完成任务了。下一次垃
圾收集的工作过程也大致类似，惟一的不同只是人们的转移方向变成了从北区到南区。如
此循环往复，每次垃圾收集都只需简单地转移（也就是复制）一次，垃圾收集速度无与伦
比——当然，对于用餐者往返奔波于南北两区之间的辛劳，垃圾收集机器人是决不会流露
出丝毫怜悯的。

M. L. Minsky 的发明绝对算得上一种奇思妙想。分区、复制的思路不仅大幅提高了垃圾收
集的效率，而且也将原本繁纷复杂的内存分配算法变得前所未有地简明和扼要（既然每次
内存回收都是对整个半区的回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移
动堆顶指针，按顺序分配内存就可以了），这简直是个奇迹！不过，任何奇迹的出现都有
一定的代价，在垃圾收集技术中，复制算法提高效率的代价是人为地将可用内存缩小了一
半。实话实说，这个代价未免也太高了一些。

无论优缺点如何，复制算法在实践中都获得了可以与标记－清除算法相比拟的成功。除了
M. L. Minsky 本人在 Lisp 语言中的工作以外，从 1960 年代末到 1970 年代初， R.
R. Fenichel 和 J. C. Yochelson 等人也相继在 Lisp 语言的不同实现中对复制算法进行
了改进， S. Arnborg 更是成功地将复制算法应用到了 Simula 语言中。

至此，垃圾收集技术的三大传统算法——引用计数算法、标记－清除算法和复制算法——
都已在 1960 年前后相继问世，三种算法各有所长，也都存在致命的缺陷。从 1960 年代
后期开始，研究者的主要精力逐渐转向对这三种传统算法进行改进或整合，以扬长避短，
适应程序设计语言和运行环境对垃圾收集的效率和实时性所提出的更高要求。

走向成熟

返回页首

从 1970 年代开始，随着科学研究和应用实践的不断深入，人们逐渐意识到，一个理想的
垃圾收集器不应在运行时导致应用程序的暂停，不应额外占用大量的内存空间和 CPU 资源
，而三种传统的垃圾收集算法都无法满足这些要求。人们必须提出更新的算法或思路，以
解决实践中碰到的诸多难题。当时，研究者的努力目标包括：

第一，提高垃圾收集的效率。使用标记－清除算法的垃圾收集器在工作时要消耗相当多的
CPU 资源。早期的 Lisp 运行环境收集内存垃圾的时间竟占到了系统总运行时间的 40%
！——垃圾收集效率的低下直接造就了 Lisp 语言在执行速度方面的坏名声；直到今天，
许多人还条件反射似地误以为所有 Lisp 程序都奇慢无比。

第二，减少垃圾收集时的内存占用。这一问题主要出现在复制算法中。尽管复制算法在效
率上获得了质的突破，但牺牲一半内存空间的代价仍然是巨大的。在计算机发展的早期，
在内存价格以 KB 计算的日子里，浪费客户的一半内存空间简直就是在变相敲诈或拦路打
劫。

第三，寻找实时的垃圾收集算法。无论执行效率如何，三种传统的垃圾收集算法在执行垃
圾收集任务时都必须打断程序的当前工作。这种因垃圾收集而造成的延时是许多程序，特
别是执行关键任务的程序没有办法容忍的。如何对传统算法进行改进，以便实现一种在后
台悄悄执行，不影响——或至少看上去不影响——当前进程的实时垃圾收集器，这显然是
一件更具挑战性的工作。

研究者们探寻未知领域的决心和研究工作的进展速度同样令人惊奇：在 1970 年代到 198
0 年代的短短十几年中，一大批在实用系统中表现优异的新算法和新思路脱颖而出。正是
因为有了这些日趋成熟的垃圾收集算法，今天的我们才能在 Java 或 .NET 提供的运行环
境中随心所欲地分配内存块，而不必担心空间释放时的风险。

标记－整理（ Mark-Compact ）算法


标记－整理算法是标记－清除算法和复制算法的有机结合。把标记－清除算法在内存占用
上的优点和复制算法在执行效率上的特长综合起来，这是所有人都希望看到的结果。不过
，两种垃圾收集算法的整合并不像 1 加 1 等于 2 那样简单，我们必须引入一些全新的思
路。 1970 年前后， G. L. Steele ， C. J. Cheney 和 D. S. Wise 等研究者陆续找到
了正确的方向，标记－整理算法的轮廓也逐渐清晰了起来：

在我们熟悉的餐厅里，这一次，垃圾收集机器人不再把餐厅分成两个南北区域了。需要执
行垃圾收集任务时，机器人先执行标记－清除算法的第一个步骤，为所有使用中的餐巾纸
画好标记，然后，机器人命令所有就餐者带上有标记的餐巾纸向餐厅的南面集中，同时把
没有标记的废旧餐巾纸扔向餐厅北面。这样一来，机器人只消站在餐厅北面，怀抱垃圾箱
，迎接扑面而来的废旧餐巾纸就行了。

实验表明，标记－整理算法的总体执行效率高于标记－清除算法，又不像复制算法那样需
要牺牲一半的存储空间，这显然是一种非常理想的结果。在许多现代的垃圾收集器中，人
们都使用了标记－整理算法或其改进版本。

增量收集（ Incremental Collecting ）算法


对实时垃圾收集算法的研究直接导致了增量收集算法的诞生。

最初，人们关于实时垃圾收集的想法是这样的：为了进行实时的垃圾收集，可以设计一个
多进程的运行环境，比如用一个进程执行垃圾收集工作，另一个进程执行程序代码。这样
一来，垃圾收集工作看上去就仿佛是在后台悄悄完成的，不会打断程序代码的运行。

在收集餐巾纸的例子中，这一思路可以被理解为：垃圾收集机器人在人们用餐的同时寻找
废弃的餐巾纸并将它们扔到垃圾箱里。这个看似简单的思路会在设计和实现时碰上进程间
冲突的难题。比如说，如果垃圾收集进程包括标记和清除两个工作阶段，那么，垃圾收集
器在第一阶段中辛辛苦苦标记出的结果很可能被另一个进程中的内存操作代码修改得面目
全非，以至于第二阶段的工作没有办法开展。

M. L. Minsky 和 D. E. Knuth 对实时垃圾收集过程中的技术难点进行了早期的研究， G
. L. Steele 于 1975 年发表了题为“多进程整理的垃圾收集（ Multiprocessing compa
ctifying garbage collection ）”的论文，描述了一种被后人称为“ Minsky-Knuth-St
eele 算法”的实时垃圾收集算法。 E. W. Dijkstra ， L. Lamport ， R. R. Fenichel
和 J. C. Yochelson 等人也相继在此领域做出了各自的贡献。 1978 年， H. G. Baker
发表了“串行计算机上的实时表处理技术（ List Processing in Real Time on a Seri
al Computer ）”一文，系统阐述了多进程环境下用于垃圾收集的增量收集算法。

增量收集算法的基础仍是传统的标记－清除和复制算法。增量收集算法通过对进程间冲突
的妥善处理，允许垃圾收集进程以分阶段的方式完成标记、清理或复制工作。详细分析各
种增量收集算法的内部机理是一件相当繁琐的事情，在这里，读者们需要了解的仅仅是：
H. G. Baker 等人的努力已经将实时垃圾收集的梦想变成了现实，我们再也不用为垃圾收
集打断程序的运行而烦恼了。

分代收集（ Generational Collecting ）算法


和大多数软件开发技术一样，统计学原理总能在技术发展的过程中起到强力催化剂的作用
。 1980 年前后，善于在研究中使用统计分析知识的技术人员发现，大多数内存块的生存
周期都比较短，垃圾收集器应当把更多的精力放在检查和清理新分配的内存块上。这个发
现对于垃圾收集技术的价值可以用餐巾纸的例子概括如下：

如果垃圾收集机器人足够聪明，事先摸清了餐厅里每个人在用餐时使用餐巾纸的习惯——
比如有些人喜欢在用餐前后各用掉一张餐巾纸，有的人喜欢自始至终攥着一张餐巾纸不放
，有的人则每打一个喷嚏就用去一张餐巾纸——机器人就可以制定出更完善的餐巾纸回收
计划，并总是在人们刚扔掉餐巾纸没多久就把垃圾捡走。这种基于统计学原理的做法当然
可以让餐厅的整洁度成倍提高。

D. E. Knuth ， T. Knight ， G. Sussman 和 R. Stallman 等人对内存垃圾的分类处理
做了最早的研究。 1983 年， H. Lieberman 和 C. Hewitt 发表了题为“基于对象寿命的
一种实时垃圾收集器（ A real-time garbage collector based on the lifetimes of o
bjects ）”的论文。这篇著名的论文标志着分代收集算法的正式诞生。此后，在 H. G.
Baker ， R. L. Hudson ， J. E. B. Moss 等人的共同努力下，分代收集算法逐渐成为了
垃圾收集领域里的主流技术。

分代收集算法通常将堆中的内存块按寿命分为两类，年老的和年轻的。垃圾收集器使用不
同的收集算法或收集策略，分别处理这两类内存块，并特别地把主要工作时间花在处理年
轻的内存块上。分代收集算法使垃圾收集器在有限的资源条件下，可以更为有效地工作—
—这种效率上的提高在今天的 Java 虚拟机中得到了最好的证明。

应用浪潮

Lisp 是垃圾收集技术的第一个受益者，但显然不是最后一个。在 Lisp 语言之后，许许多
多传统的、现代的、后现代的语言已经把垃圾收集技术拉入了自己的怀抱。随便举几个例
子吧：诞生于 1964 年的 Simula 语言， 1969 年的 Smalltalk 语言， 1970 年的 Prol
og 语言， 1973 年的 ML 语言， 1975 年的 Scheme 语言， 1983 年的 Modula-3 语言，
1986 年的 Eiffel 语言， 1987 年的 Haskell 语言……它们都先后使用了自动垃圾收集
技术。当然，每一种语言使用的垃圾收集算法可能不尽相同，大多数语言和运行环境甚至
同时使用了多种垃圾收集算法。但无论怎样，这些实例都说明，垃圾收集技术从诞生的那
一天起就不是一种曲高和寡的“学院派”技术。

对于我们熟悉的 C 和 C++ 语言，垃圾收集技术一样可以发挥巨大的功效。正如我们在学
校中就已经知道的那样， C 和 C++ 语言本身并没有提供垃圾收集机制，但这并不妨碍我
们在程序中使用具有垃圾收集功能的函数库或类库。例如，早在 1988 年， H. J. Boehm
和 A. J. Demers 就成功地实现了一种使用保守垃圾收集算法（ Conservative GC Algo
rithmic ）的函数库（参见[http://www.hpl.hp.com/personal/Hans_Boehm/gc]()）。我们
可以在 C 语言或 C++ 语言中使用该函数库完成自动垃圾收集功能，必要时，甚至还可以
让传统的 C/C++ 代码与使用自动垃圾收集功能的 C/C++ 代码在一个程序里协同工作。


1995 年诞生的 Java 语言在一夜之间将垃圾收集技术变成了软件开发领域里最为流行的技
术之一。从某种角度说，我们很难分清究竟是 Java 从垃圾收集中受益，还是垃圾收集技
术本身借 Java 的普及而扬名。值得注意的是，不同版本的 Java 虚拟机使用的垃圾收集
机制并不完全相同， Java 虚拟机其实也经过了一个从简单到复杂的发展过程。在 Java
虚拟机的 1.4.1 版中，人们可以体验到的垃圾收集算法就包括分代收集、复制收集、增量
收集、标记－整理、并行复制（ Parallel Copying ）、并行清除（ Parallel Scavengi
ng ）、并发（ Concurrent ）收集等许多种， Java 程序运行速度的不断提升在很大程度
上应该归功于垃圾收集技术的发展与完善。

尽管历史上已经有许多包含垃圾收集技术的应用平台和操作系统出现，但 Microsoft .NE
T 却是第一种真正实用化的、包含了垃圾收集机制的通用语言运行环境。事实上， .NET
平台上的所有语言，包括 C# 、 Visual Basic .NET 、 Visual C++ .NET 、 J# 等等，
都可以通过几乎完全相同的方式使用 .NET 平台提供的垃圾收集机制。我们似乎可以断言
， .NET 是垃圾收集技术在应用领域里的一次重大变革，它使垃圾收集技术从一种单纯的
技术变成了应用环境乃至操作系统中的一种内在文化。这种变革对未来软件开发技术的影
响力也许要远远超过 .NET 平台本身的商业价值。

大势所趋

今天，致力于垃圾收集技术研究的人们仍在不懈努力，他们的研究方向包括分布式系统的
垃圾收集、复杂事务环境下的垃圾收集、数据库等特定系统的垃圾收集等等。

但在程序员中间，仍有不少人对垃圾收集技术不屑一顾，他们宁愿相信自己逐行编写的 f
ree 或 delete 命令，也不愿把垃圾收集的重任交给那些在他们看来既蠢又笨的垃圾收集
器。

我个人认为，垃圾收集技术的普及是大势所趋，这就像生活会越来越好一样毋庸置疑。今
天的程序员也许会因为垃圾收集器要占用一定的 CPU 资源而对其望而却步，但二十多年前
的程序员还曾因为高级语言速度太慢而坚持用机器语言写程序呢！在硬件速度日新月异的
今天，我们是要吝惜那一点儿时间损耗而踟躇不前，还是该坚定不移地站在代码和运行环
境的净化剂——垃圾收集的一边呢？

[王咏刚，2003年12月]
