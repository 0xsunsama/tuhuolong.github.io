---
layout: post
title: "Floyd算法"
date: 2011-05-13 10:53:00 
comments: true
categories: [算法]
tags: [算法]
description: "Floyd算法"
keywords: 算法
---


 
 
 
  
   Floyd
  
  
   算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点
  
  
   i
  
  
   到点
  
  
   j
  
  
   的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在），
  
  
   floyd
  
  
   算法加入了这个概念
  
 
 
 
 
  
   A
   
    k
   
   (i,j)
  
  
   ：表示从
  
  
   
    i
   
   
    到
   
   
    j
   
   
    (只考虑1,2,...,k)的最短路径----------中途不经过索引比
   
   
    k
   
   
    大的点的最短路径
   
  
  
   。
  
 
 
  
  
  
   这个限制的重要之处在于，它将最短路径的概念做了限制，使得该限制有机会满足迭代关系，这个迭代关系就在于研究：假设
  
  
   A
   
    k
   
   (i,j)
  
  
   已知，是否可以借此推导出
  
  
   A
   
    k-1
   
   (i,j)
  
  
   。
  
 
 
  
  
  
   假设我现在要得到
  
  
   A
   
    k
   
   (i,j)
  
  
   ，而此时
  
  
   A
   
    k
   
   (i,j)
  
  
   已知，那么我可以分两种情况来看待问题：
  
  
   1. A
   
    k
   
   (i,j)
  
  
   沿途经过点
  
  
   k
  
  
   ；
  
  
   2. A
   
    k
   
   (i,j)
  
  
   不经过点
  
  
   k
  
  
   。如果经过点
  
  
   k
  
  
   ，那么很显然，
  
  
   A
   
    k
   
   (i,j)= A
   
    k-1
   
   (i,k)
 + A
   
    k-1
   
   (k,j)
  
  
   ，为什么是
  
  
   A
   
    k-1
   
  
  
   呢？因为对
  
  
   (i,k)
  
  
   和
  
  
   (k,j)
  
  
   ，由于
  
  
   k
  
  
   本身就是源点（或者说终点），加上我们求的是
  
  
   A
   
    k
   
   (i,j)
  
  
   ，所以满足不经过比
  
  
   k
  
  
   大的点的条件限制，且已经不会经过点
  
  
   k
  
  
   ，故得出了
  
  
   A
   
    k-1
   
  
  
   这个值。那么遇到第二种情况，
  
  
   A
   
    k
   
   (i,j)
  
  
   不经过点
  
  
   k
  
  
   时，由于没有经过点
  
  
   k
  
  
   ，所以根据概念，可以得出
  
  
   A
   
    k
   
   (i,j)=A
   
    k-1
   
   (i,j)
  
  
   。现在，我们确信有且只有这两种情况
  
  
   ---
  
  
   不是经过点
  
  
   k
  
  
   ，就是不经过点
  
  
   k
  
  
   ，没有第三种情况了，条件很完整，那么是选择哪一个呢？很简单，求的是最短路径，当然是哪个最短，求取哪个，故得出式子：
  
 
 
  
   A
   
    k
   
   (i,j) =min( A
   
    k-1
   
   (i,j), A
   
    k-1
   
   (i,k) + A
   
    k-1
   
   (k,j))
  
 
 
  
   
   
  
  
   因此
  
  
   floyd
  
  
   的最外层循环：
  
  
   
   
  
  
   for (k = 0; k < n; k++) ...
  
  
   
   
  
  
   就是分别求出
  
  
  
  
   A0(i,j), A1(i,j),..., An(i,j)
  
  
   
   
  
  
   我屡次写错
  
  
   floyd
  
  
   的程序，今天又写错一次。。尽管它很短，但原理真的很牛比。
  
  
   
   
  
  
   只要知道了原理，就不会再写错了！
  
 
 
  
   
   
  
 
 
  
   
    d(ij)>;0表示i城市到j城市的距离。若i与j之间无路可通，那么d(ij)就是无穷大。又有d(ii)=0
   
   
   
  
 
 
 


