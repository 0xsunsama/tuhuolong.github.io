---
layout: post
title: Floyd算法
date: 2011-05-13 10:53:00
categories: [算法]
tags: [算法, 语言]
---
 
Floyd算法是一个经典的动态规划算法。用通俗的语言来描述的话，首先我们的目标是寻找从点i到点j的最短路径。从动态规划的角度看问题，我们需要为这个目标重新做一个诠释（这个诠释正是动态规划最富创造力的精华所在），floyd算法加入了这个概念
 
    Ak(i,j)：表示从**i到j(只考虑1,2,...,k)的最短路径----------中途不经过索引比k大的点的最短路径**。
    这个限制的重要之处在于，它将最短路径的概念做了限制，使得该限制有机会满足迭代关系，这个迭代关系就在于研究：假设Ak(i,j)已知，是否可以借此推导出Ak-1(i,j)。
    假设我现在要得到Ak(i,j)，而此时Ak(i,j)已知，那么我可以分两种情况来看待问题：1. Ak(i,j)沿途经过点k；2. Ak(i,j)不经过点k。如果经过点k，那么很显然，Ak(i,j)= Ak-1(i,k)
 + Ak-1(k,j)，为什么是Ak-1呢？因为对(i,k)和(k,j)，由于k本身就是源点（或者说终点），加上我们求的是Ak(i,j)，所以满足不经过比k大的点的条件限制，且已经不会经过点k，故得出了Ak-1这个值。那么遇到第二种情况，Ak(i,j)不经过点k时，由于没有经过点k，所以根据概念，可以得出Ak(i,j)=Ak-1(i,j)。现在，我们确信有且只有这两种情况---不是经过点k，就是不经过点k，没有第三种情况了，条件很完整，那么是选择哪一个呢？很简单，求的是最短路径，当然是哪个最短，求取哪个，故得出式子：
    Ak(i,j) =min( Ak-1(i,j), Ak-1(i,k) + Ak-1(k,j))

因此floyd的最外层循环：
for (k = 0; k < n; k++) ...
就是分别求出 A0(i,j), A1(i,j),..., An(i,j) 
我屡次写错floyd的程序，今天又写错一次。。尽管它很短，但原理真的很牛比。
只要知道了原理，就不会再写错了！


d(ij)>0表示i城市到j城市的距离。若i与j之间无路可通，那么d(ij)就是无穷大。又有d(ii)=0

 
